<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>钓鱼功能测试</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #74b9ff, #0984e3);
        }
        
        #gameContainer {
            position: relative;
            background: transparent;
            border-radius: 0;
            padding: 0;
            box-shadow: none;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        
        #gameCanvas {
            border: none;
            border-radius: 0;
            display: block;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
        }
        
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
            text-align: center;
            pointer-events: none;
        }
        
        .game-overlay > * {
            pointer-events: auto;
        }
        
        .controls {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            margin: 0;
            display: flex;
            flex-direction: row;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            white-space: nowrap;
        }
        
        button:hover {
            background: #45a049;
        }
        
        h1 {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            margin: 0;
            padding: 0;
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 11;
        }
        
        html {
            margin: 0;
            padding: 0;
            height: 100%;
        }

    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        
        <h1><svg width="48" height="48" viewBox="0 0 64 64" style="vertical-align: middle; margin-right: 8px;">
            <!-- 猫咪头部 -->
            <circle cx="32" cy="28" r="18" fill="#FF8C69"/>
            
            <!-- 猫咪耳朵 -->
            <polygon points="20,16 26,6 30,16" fill="#E55555"/>
            <polygon points="34,16 38,6 44,16" fill="#E55555"/>
            
            <!-- 耳朵内部 -->
            <polygon points="22,15 26,9 28,15" fill="#FFB6C1"/>
            <polygon points="36,15 38,9 42,15" fill="#FFB6C1"/>
            
            <!-- 猫咪眼睛 -->
            <ellipse cx="26" cy="24" rx="3" ry="4" fill="#000"/>
            <ellipse cx="38" cy="24" rx="3" ry="4" fill="#000"/>
            
            <!-- 眼睛高光 -->
            <circle cx="27" cy="22" r="1" fill="#FFF"/>
            <circle cx="39" cy="22" r="1" fill="#FFF"/>
            
            <!-- 鼻子 -->
            <polygon points="32,30 30,34 34,34" fill="#FF69B4"/>
            
            <!-- 嘴巴 -->
            <path d="M32,34 Q26,36 22,32" stroke="#000" stroke-width="1.5" fill="none"/>
            <path d="M32,34 Q38,36 42,32" stroke="#000" stroke-width="1.5" fill="none"/>
            
            <!-- 胡须 -->
            <line x1="16" y1="26" x2="8" y2="24" stroke="#000" stroke-width="1"/>
            <line x1="16" y1="30" x2="8" y2="30" stroke="#000" stroke-width="1"/>
            <line x1="16" y1="34" x2="8" y2="36" stroke="#000" stroke-width="1"/>
            <line x1="48" y1="26" x2="56" y2="24" stroke="#000" stroke-width="1"/>
            <line x1="48" y1="30" x2="56" y2="30" stroke="#000" stroke-width="1"/>
            <line x1="48" y1="34" x2="56" y2="36" stroke="#000" stroke-width="1"/>
            
            <!-- 猫咪身体 -->
            <ellipse cx="32" cy="48" rx="12" ry="8" fill="#FF8C69"/>
            
            <!-- 前腿 -->
            <rect x="24" y="52" width="4" height="8" fill="#FF8C69"/>
            <rect x="36" y="52" width="4" height="8" fill="#FF8C69"/>
            
            <!-- 爪子 -->
            <circle cx="26" cy="60" r="2" fill="#E55555"/>
            <circle cx="38" cy="60" r="2" fill="#E55555"/>
        </svg> 小猫钓鱼</h1>

        <div class="controls">
            <button onclick="startGame()" id="startButton" style="background: #4CAF50; font-weight: bold;">🎮 开始游戏</button>
            <button onclick="toggleBackgroundMusic()" id="musicToggle" style="background: #FF6B6B; font-weight: bold;">🎵 播放音乐</button>
        </div>
        

    </div>
    
    <!-- 游戏脚本 -->
    <script src="src/adapter.js"></script>
    <script src="src/main.js"></script>
    <script src="src/audio/AudioManager.js"></script>
    <script src="src/animation/AnimationManager.js"></script>
    <script src="src/effects/ParticleSystem.js"></script>
    <script src="src/entities/Cat.js?v=20250131"></script>
<script src="src/entities/Fish.js?v=20250131"></script>
<script src="src/entities/Obstacle.js?v=20250131"></script>
<script src="src/entities/PowerUp.js?v=20250131"></script>
<script src="src/systems/Spawner.js?v=20250131"></script>
<script src="src/systems/CollisionSystem.js?v=20250131"></script>
<script src="src/systems/ScoreSystem.js?v=20250131"></script>
<script src="src/ui/UIManager.js?v=20250131"></script>
<script src="src/scenes/MainMenu.js?v=20250131"></script>
<script src="src/scenes/GameScene.js?v=20250131"></script>
<script src="src/scenes/GameOver.js?v=20250131"></script>
    
    <script>
        let canvas, ctx, cat, animationManager, audioManager, fishes, fishSpawnTimer;
        
        // 游戏时间管理
        let gameTime = 90; // 90秒 = 1.5分钟
        let gameTimer = 0;
        let isGameActive = true;
        
        // 钓鱼计数
        let caughtFishCount = 0;
        
        // 音效播放函数
        function playCatchSound() {
            try {
                // 使用AudioManager播放钓鱼成功音效
                if (audioManager) {
                    audioManager.playSfx('fishCaught');
                    debugLog('播放钓鱼成功音效', 'info');
                } else {
                    // 备用方案：直接播放音频文件
                    const catchAudio = new Audio('audio/catch.mp3');
                    catchAudio.volume = 0.7;
                    catchAudio.play().catch(e => {
                        console.log('音效播放失败:', e);
                    });
                }
            } catch (error) {
                console.log('音效播放出错:', error);
            }
        }
        
        // 播放投掷鱼竿音效
        function playCastSound() {
            try {
                if (audioManager) {
                    audioManager.playSfx('cast');
                    debugLog('播放投掷鱼竿音效', 'info');
                }
            } catch (error) {
                console.log('投掷音效播放出错:', error);
            }
        }
        
        // 播放收杆音效
        function playReelSound() {
            try {
                if (audioManager) {
                    audioManager.playSfx('reel');
                    debugLog('播放收杆音效', 'info');
                }
            } catch (error) {
                console.log('收杆音效播放出错:', error);
            }
        }
        
        // 生成合成背景音乐
        function generateBackgroundMusic() {
            try {
                debugLog('开始生成合成背景音乐...', 'info');
                
                // 创建音频上下文
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // 创建一个简单的旋律
                const notes = [
                    { freq: 261.63, duration: 0.5 }, // C4
                    { freq: 293.66, duration: 0.5 }, // D4
                    { freq: 329.63, duration: 0.5 }, // E4
                    { freq: 349.23, duration: 0.5 }, // F4
                    { freq: 392.00, duration: 0.5 }, // G4
                    { freq: 440.00, duration: 0.5 }, // A4
                    { freq: 493.88, duration: 0.5 }, // B4
                    { freq: 523.25, duration: 1.0 }  // C5
                ];
                
                const totalDuration = notes.reduce((sum, note) => sum + note.duration, 0);
                const sampleRate = audioContext.sampleRate;
                const bufferLength = sampleRate * totalDuration;
                const buffer = audioContext.createBuffer(1, bufferLength, sampleRate);
                const channelData = buffer.getChannelData(0);
                
                let currentTime = 0;
                
                notes.forEach(note => {
                    const startSample = Math.floor(currentTime * sampleRate);
                    const endSample = Math.floor((currentTime + note.duration) * sampleRate);
                    
                    for (let i = startSample; i < endSample && i < bufferLength; i++) {
                        const t = (i - startSample) / sampleRate;
                        const envelope = Math.exp(-t * 2); // 衰减包络
                        channelData[i] += Math.sin(2 * Math.PI * note.freq * t) * envelope * 0.1;
                    }
                    
                    currentTime += note.duration;
                });
                
                debugLog('合成音乐生成完成', 'success');
                return { audioContext, buffer };
                
            } catch (error) {
                debugLog('生成合成音乐失败: ' + error.message, 'error');
                return null;
            }
        }
        
        // 准备背景音乐（不立即播放）
        function prepareBackgroundMusic() {
            try {
                if (!window.bgmAudio) {
                    debugLog('开始创建背景音乐对象...', 'info');
                    
                    // 生成合成背景音乐
                    const musicData = generateBackgroundMusic();
                    
                    if (!musicData) {
                        debugLog('无法生成背景音乐', 'error');
                        return;
                    }
                    
                    // 创建音频源节点
                    const source = musicData.audioContext.createBufferSource();
                    source.buffer = musicData.buffer;
                    source.loop = true; // 循环播放
                    
                    // 创建增益节点控制音量
                    const gainNode = musicData.audioContext.createGain();
                    gainNode.gain.value = 0.3; // 设置音量为30%
                    
                    // 连接音频节点
                    source.connect(gainNode);
                    gainNode.connect(musicData.audioContext.destination);
                    
                    // 保存音频对象以便后续控制
                    window.bgmAudio = {
                        audioContext: musicData.audioContext,
                        source: source,
                        gainNode: gainNode,
                        isPlaying: false,
                        paused: true,
                        volume: 0.3,
                        
                        play: function() {
                            return new Promise((resolve, reject) => {
                                try {
                                    if (this.audioContext.state === 'suspended') {
                                        this.audioContext.resume().then(() => {
                                            if (!this.isPlaying) {
                                                this.source.start();
                                                this.isPlaying = true;
                                                this.paused = false;
                                                debugLog('合成背景音乐开始播放', 'success');
                                            }
                                            resolve();
                                        }).catch(reject);
                                    } else {
                                        if (!this.isPlaying) {
                                            this.source.start();
                                            this.isPlaying = true;
                                            this.paused = false;
                                            debugLog('合成背景音乐开始播放', 'success');
                                        }
                                        resolve();
                                    }
                                } catch (error) {
                                    reject(error);
                                }
                            });
                        },
                        
                        pause: function() {
                            if (this.audioContext.state === 'running') {
                                this.audioContext.suspend();
                                this.paused = true;
                                debugLog('合成背景音乐已暂停', 'info');
                            }
                        },
                        
                        resume: function() {
                            if (this.audioContext.state === 'suspended') {
                                this.audioContext.resume();
                                this.paused = false;
                                debugLog('合成背景音乐已恢复', 'info');
                            }
                        }
                    };
                    
                    window.musicReady = true;
                    debugLog('合成背景音乐对象创建完成', 'success');
                }
            } catch (error) {
                debugLog('背景音乐准备失败: ' + error.message, 'error');
                console.error('背景音乐准备失败:', error);
            }
        }
        
        // 播放背景音乐
        function playBackgroundMusic() {
            try {
                debugLog('尝试播放背景音乐...', 'info');
                
                if (!window.bgmAudio) {
                    debugLog('音频对象不存在，准备创建...', 'warning');
                    prepareBackgroundMusic();
                    setTimeout(() => playBackgroundMusic(), 500);
                    return;
                }
                
                debugLog('音频对象存在，检查状态...', 'info');
                debugLog('音频就绪状态: ' + (window.musicReady ? '是' : '否'), 'info');
                debugLog('音频上下文状态: ' + window.bgmAudio.audioContext.state, 'info');
                debugLog('音频播放状态: ' + (window.bgmAudio.paused ? '暂停' : '播放'), 'info');
                
                if (window.musicReady && window.bgmAudio.paused) {
                    debugLog('开始播放合成背景音乐...', 'info');
                    
                    const playPromise = window.bgmAudio.play();
                    
                    if (playPromise) {
                        playPromise.then(() => {
                            debugLog('背景音乐播放成功！', 'success');
                            const toggleButton = document.getElementById('musicToggle');
                            if (toggleButton) {
                                toggleButton.textContent = '🎵 暂停音乐';
                            }
                        }).catch(error => {
                            debugLog('播放失败: ' + error.name + ' - ' + error.message, 'error');
                            console.error('音频播放错误:', error);
                            
                            // 如果是用户交互问题，提示用户
                            if (error.name === 'NotAllowedError') {
                                debugLog('浏览器阻止了音频播放，请手动点击播放按钮', 'warning');
                            }
                        });
                    }
                } else if (!window.bgmAudio.paused) {
                    debugLog('背景音乐已在播放中', 'info');
                } else {
                    debugLog('音频未就绪，等待中...', 'warning');
                    setTimeout(() => playBackgroundMusic(), 500);
                }
                
            } catch (error) {
                debugLog('播放音乐时发生异常: ' + error.message, 'error');
                console.error('播放音乐异常:', error);
            }
        }
        
        // 停止背景音乐
        function stopBackgroundMusic() {
            try {
                if (window.bgmAudio) {
                    window.bgmAudio.pause();
                    // 对于合成音频，我们重置播放状态
                    window.bgmAudio.isPlaying = false;
                    debugLog('背景音乐已停止', 'info');
                    const toggleButton = document.getElementById('musicToggle');
                    if (toggleButton) {
                        toggleButton.textContent = '🎵 播放音乐';
                    }
                }
            } catch (error) {
                debugLog('停止背景音乐失败: ' + error.message, 'error');
            }
        }
        
        // 切换背景音乐播放状态
        function toggleBackgroundMusic() {
            try {
                debugLog('用户点击音乐切换按钮', 'info');
                const toggleButton = document.getElementById('musicToggle');
                
                if (window.bgmAudio) {
                    debugLog('音频对象存在，当前状态: ' + (window.bgmAudio.paused ? '暂停' : '播放'), 'info');
                    
                    if (window.bgmAudio.paused) {
                        // 当前暂停，开始播放或恢复
                        debugLog('尝试播放/恢复音乐...', 'info');
                        
                        if (window.bgmAudio.isPlaying) {
                            // 已经在播放，只是被暂停了，恢复播放
                            window.bgmAudio.resume();
                            toggleButton.textContent = '🎵 暂停音乐';
                        } else {
                            // 还没开始播放，开始播放
                            const playPromise = window.bgmAudio.play();
                            
                            if (playPromise) {
                                playPromise.then(() => {
                                    debugLog('背景音乐播放成功', 'success');
                                    toggleButton.textContent = '🎵 暂停音乐';
                                }).catch(error => {
                                    debugLog('播放失败: ' + error.name + ' - ' + error.message, 'error');
                                    console.error('播放错误:', error);
                                });
                            }
                        }
                    } else {
                        // 当前播放，暂停
                        debugLog('暂停背景音乐', 'info');
                        window.bgmAudio.pause();
                        toggleButton.textContent = '🎵 播放音乐';
                    }
                } else {
                    // 没有音频对象，重新创建并播放
                    debugLog('音频对象不存在，创建并播放', 'warning');
                    playBackgroundMusic();
                }
            } catch (error) {
                debugLog('切换音乐状态失败: ' + error.message, 'error');
                console.error('切换音乐状态错误:', error);
            }
        }
        
        function debugLog(message, type = 'info') {
            const debugDiv = document.getElementById('debugInfo');
            if (debugDiv) {
                const line = document.createElement('div');
                line.className = `debug-line debug-${type}`;
                line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                debugDiv.appendChild(line);
                debugDiv.scrollTop = debugDiv.scrollHeight;
            }
            console.log(`[DEBUG-${type.toUpperCase()}] ${message}`);
        }
        
        function clearDebugLog() {
            const debugDiv = document.getElementById('debugInfo');
            if (debugDiv) {
                debugDiv.innerHTML = '<div class="debug-line debug-info">日志已清空...</div>';
            }
        }
        
        // 初始化测试环境
        async function initTest() {
            try {
                canvas = document.getElementById('gameCanvas');
                ctx = canvas.getContext('2d');
                
                // 确保GameGlobal存在
                if (!window.GameGlobal) {
                    debugLog('GameGlobal未找到，创建基本配置', 'warning');
                    window.GameGlobal = {
                        canvas: canvas,
                        ctx: ctx,
                        GameConfig: {
                            FISHING_SPEED: 200,
                            FISH_SCORES: { small: 10, medium: 20, large: 30 },
                            OBSTACLE_PENALTY: 10
                        },
                        GameState: {
                            reset: () => {},
                            isPaused: false,
                            isGameOver: false
                        },
                        Utils: {
                            getDistance: (x1, y1, x2, y2) => {
                                const dx = x2 - x1;
                                const dy = y2 - y1;
                                return Math.sqrt(dx * dx + dy * dy);
                            },
                            random: (min, max) => {
                                if (max === undefined) {
                                    max = min;
                                    min = 0;
                                }
                                return Math.random() * (max - min) + min;
                            },
                            clamp: (value, min, max) => {
                                return Math.min(Math.max(value, min), max);
                            }
                        }
                    };
                }
                
                // 创建动画管理器
                animationManager = new window.AnimationManager();
                debugLog('动画管理器创建成功', 'success');
                
                // 创建音频管理器
                audioManager = new window.AudioManager();
                await audioManager.init();
                debugLog('音频管理器创建成功', 'success');
                
                // 准备背景音乐（但不立即播放，等待用户交互）
                prepareBackgroundMusic();
                debugLog('背景音乐已准备就绪，等待用户交互后播放', 'info');
                
                // 确保GameGlobal.canvas正确设置
                window.GameGlobal.canvas = canvas;
                window.GameGlobal.ctx = ctx;
                
                // 创建小猫对象
                cat = new window.Cat(canvas.width / 2 - 30, 80);
                cat.init(); // 手动调用init方法
                cat.setAnimationManager(animationManager);
                debugLog('小猫对象创建成功', 'success');
                
                // 创建鱼类数组
                fishes = [];
                fishSpawnTimer = 0;
                
                // 生成初始鱼类
                spawnInitialFishes();
                
                // 开始渲染循环
                startRenderLoop();
                
                debugLog('测试环境初始化完成', 'success');
                
            } catch (error) {
                debugLog(`初始化失败: ${error.message}`, 'error');
                console.error('初始化错误:', error);
            }
        }
        
        // 波光粼粼效果变量
        let waveTime = 0;
        let ripples = [];
        
        // 添加水波纹效果
        function addRipple(x, y) {
            ripples.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: 50 + Math.random() * 30,
                alpha: 1,
                speed: 2 + Math.random()
            });
        }
        
        // 将addRipple函数暴露到全局作用域
        window.addRipple = addRipple;
        
        // 绘制真实鱼塘背景
        function drawPondBackground(currentTime) {
            // 绘制水面渐变背景
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');   // 天空蓝
            gradient.addColorStop(0.3, '#4ECDC4'); // 浅水蓝绿
            gradient.addColorStop(0.6, '#2E8B57'); // 海绿色
            gradient.addColorStop(1, '#1C4E63');   // 深水蓝
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制水底装饰
            drawPondDecorations();
            
            // 绘制波光粼粼效果
            drawWaterShimmer(currentTime);
            
            // 绘制水面波纹
            drawWaterRipples();
            
            // 绘制水面反光
            drawWaterReflection();
        }
        
        // 绘制鱼塘装饰元素
        function drawPondDecorations() {
            // 绘制水底石头
            drawPondRocks();
            
            // 绘制水草
            drawPondWeeds();
            
            // 绘制水底沙地纹理
            drawPondBottom();
        }
        
        // 绘制水底石头
        function drawPondRocks() {
            const rocks = [
                { x: 100, y: canvas.height - 80, width: 40, height: 25 },
                { x: 300, y: canvas.height - 60, width: 30, height: 20 },
                { x: 500, y: canvas.height - 90, width: 50, height: 30 },
                { x: 650, y: canvas.height - 70, width: 35, height: 22 }
            ];
            
            rocks.forEach(rock => {
                ctx.save();
                ctx.globalAlpha = 0.7;
                
                // 石头主体
                const gradient = ctx.createRadialGradient(
                    rock.x + rock.width * 0.3, rock.y + rock.height * 0.3, 0,
                    rock.x + rock.width * 0.5, rock.y + rock.height * 0.5, rock.width
                );
                gradient.addColorStop(0, '#8B7D6B');
                gradient.addColorStop(1, '#5D4E37');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(rock.x + rock.width/2, rock.y + rock.height/2, 
                           rock.width/2, rock.height/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 石头高光
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.ellipse(rock.x + rock.width * 0.3, rock.y + rock.height * 0.3, 
                           rock.width * 0.2, rock.height * 0.15, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }
        
        // 绘制水草
        function drawPondWeeds() {
            const weeds = [
                { x: 50, y: canvas.height - 120, height: 80, sway: 0 },
                { x: 200, y: canvas.height - 100, height: 60, sway: 1 },
                { x: 400, y: canvas.height - 130, height: 90, sway: 0.5 },
                { x: 600, y: canvas.height - 110, height: 70, sway: 1.5 },
                { x: 750, y: canvas.height - 95, height: 55, sway: 0.8 }
            ];
            
            weeds.forEach(weed => {
                ctx.save();
                ctx.globalAlpha = 0.6;
                
                const swayOffset = Math.sin(waveTime * 2 + weed.sway) * 8;
                
                // 绘制多片水草叶子
                for (let i = 0; i < 3; i++) {
                    const leafX = weed.x + i * 8 - 8;
                    const leafWidth = 6;
                    const segments = 8;
                    
                    ctx.strokeStyle = i === 1 ? '#228B22' : '#32CD32';
                    ctx.lineWidth = leafWidth - i;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(leafX, weed.y);
                    
                    for (let j = 1; j <= segments; j++) {
                        const t = j / segments;
                        const y = weed.y - weed.height * t;
                        const x = leafX + Math.sin(t * Math.PI + waveTime + weed.sway) * swayOffset * t;
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }
        
        // 绘制水底沙地
        function drawPondBottom() {
            ctx.save();
            ctx.globalAlpha = 0.4;
            
            // 沙地渐变
            const sandGradient = ctx.createLinearGradient(0, canvas.height - 50, 0, canvas.height);
            sandGradient.addColorStop(0, 'rgba(194, 178, 128, 0)');
            sandGradient.addColorStop(1, 'rgba(160, 144, 94, 0.8)');
            
            ctx.fillStyle = sandGradient;
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
            
            // 沙地纹理点
            ctx.fillStyle = 'rgba(139, 125, 107, 0.3)';
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * canvas.width;
                const y = canvas.height - 50 + Math.random() * 50;
                const size = Math.random() * 2 + 1;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // 绘制波光粼粼效果
        function drawWaterShimmer(currentTime) {
            waveTime = currentTime * 0.001;
            
            // 创建多层波光效果
            for (let layer = 0; layer < 3; layer++) {
                ctx.save();
                ctx.globalAlpha = 0.1 + layer * 0.05;
                
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                
                // 绘制波浪形状的光斑
                ctx.beginPath();
                for (let x = 0; x <= canvas.width; x += 10) {
                    const y1 = canvas.height * 0.3 + Math.sin(x * 0.01 + waveTime * (2 + layer)) * (15 + layer * 5);
                    const y2 = y1 + 20 + layer * 10;
                    
                    if (x === 0) {
                        ctx.moveTo(x, y1);
                    } else {
                        ctx.lineTo(x, y1);
                    }
                }
                
                for (let x = canvas.width; x >= 0; x -= 10) {
                    const y2 = canvas.height * 0.3 + Math.sin(x * 0.01 + waveTime * (2 + layer)) * (15 + layer * 5) + 20 + layer * 10;
                    ctx.lineTo(x, y2);
                }
                
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }
        
        // 绘制水面波纹
        function drawWaterRipples() {
            // 更新波纹
            ripples = ripples.filter(ripple => {
                ripple.radius += ripple.speed;
                ripple.alpha = Math.max(0, 1 - (ripple.radius / ripple.maxRadius));
                return ripple.alpha > 0;
            });
            
            // 绘制波纹
            ripples.forEach(ripple => {
                ctx.save();
                ctx.globalAlpha = ripple.alpha * 0.6;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });
            
            // 随机添加新波纹
            if (Math.random() < 0.02) {
                addRipple(
                    Math.random() * canvas.width,
                    canvas.height * 0.4 + Math.random() * canvas.height * 0.5
                );
            }
        }
        
        // 绘制水面反光
        function drawWaterReflection() {
            // 绘制动态的水面反光线
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 5; i++) {
                ctx.setLineDash([5 + i * 2, 10 + i * 3]);
                ctx.beginPath();
                
                const baseY = canvas.height * 0.4 + i * 30;
                for (let x = 0; x <= canvas.width; x += 20) {
                    const y = baseY + Math.sin(x * 0.02 + waveTime * (1 + i * 0.5)) * (3 + i);
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            ctx.restore();
        }
        
        function startRenderLoop() {
            let lastTime = 0;
            
            function render(currentTime) {
                const deltaTime = (currentTime - lastTime) / 1000;
                lastTime = currentTime;
                
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 绘制真实鱼塘背景
                drawPondBackground(currentTime);
                
                // 更新游戏时间
                updateGameTimer(deltaTime);
                
                // 更新鱼类生成
                updateFishSpawning(deltaTime);
                
                // 更新和渲染鱼类
                updateAndRenderFishes(deltaTime);
                
                // 更新和渲染小猫
                if (cat) {
                    cat.update(deltaTime);
                    cat.render(ctx);
                }
                
                // 检查碰撞
                checkFishingCollisions();
                
                // 更新动画管理器
                if (animationManager) {
                    animationManager.update(deltaTime);
                }
                
                // 显示调试信息
                renderDebugInfo();
                
                requestAnimationFrame(render);
            }
            
            requestAnimationFrame(render);
        }
        
        // 生成初始鱼类
        function spawnInitialFishes() {
            for (let i = 0; i < 10; i++) {
                spawnFish();
            }
            debugLog('生成了10条初始鱼类', 'success');
        }
        
        // 生成单条鱼
        function spawnFish() {
            const fishTypes = ['shark', 'loach', 'grass_carp', 'whale', 'crucian_carp', 'bighead_carp', 'goldfish'];
            const fishType = fishTypes[Math.floor(Math.random() * fishTypes.length)];
            
            const fish = {
                type: fishType,
                x: Math.random() * (canvas.width - 60),
                y: canvas.height * 0.4 + Math.random() * (canvas.height * 0.55),
                width: getFishSize(fishType).width,
                height: getFishSize(fishType).height,
                speed: 30 + Math.random() * 50,
                direction: Math.random() > 0.5 ? 1 : -1,
                color: getFishColor(fishType),
                secondaryColor: getSecondaryColor(fishType),
                pattern: getFishPattern(fishType),
                animationTime: 0,
                isActive: true,
                glowEffect: fishType === 'rare',
                glowIntensity: 0,
                tailType: getTailType(fishType),
                finType: getFinType(fishType)
            };
            
            fishes.push(fish);
        }
        
        // 获取鱼类大小
        function getFishSize(type) {
            const sizes = {
                shark: { width: 70, height: 35 },
                loach: { width: 25, height: 15 },
                grass_carp: { width: 50, height: 30 },
                whale: { width: 90, height: 50 },
                crucian_carp: { width: 35, height: 25 },
                bighead_carp: { width: 55, height: 40 },
                goldfish: { width: 30, height: 25 }
            };
            return sizes[type] || sizes.goldfish;
        }
        
        // 获取鱼类主颜色
        function getFishColor(type) {
            const colors = {
                shark: '#708090',
                loach: '#8B4513',
                grass_carp: '#228B22',
                whale: '#2F4F4F',
                crucian_carp: '#D2691E',
                bighead_carp: '#696969',
                goldfish: '#FFD700'
            };
            return colors[type] || colors.goldfish;
        }
        
        // 获取鱼类次要颜色
        function getSecondaryColor(type) {
            const colors = {
                shark: '#2F4F4F',
                loach: '#654321',
                grass_carp: '#006400',
                whale: '#191970',
                crucian_carp: '#B8860B',
                bighead_carp: '#2F2F2F',
                goldfish: '#FFA500'
            };
            return colors[type] || colors.goldfish;
        }
        
        // 获取鱼类图案
        function getFishPattern(type) {
            const patterns = {
                shark: 'smooth',
                loach: 'solid',
                grass_carp: 'scales',
                whale: 'gradient',
                crucian_carp: 'solid',
                bighead_carp: 'gradient',
                goldfish: 'sparkle'
            };
            return patterns[type] || 'solid';
        }
        
        // 获取尾巴类型
        function getTailType(type) {
            const tailTypes = {
                shark: 'crescent',
                loach: 'rounded',
                grass_carp: 'forked',
                whale: 'broad',
                crucian_carp: 'rounded',
                bighead_carp: 'broad',
                goldfish: 'flowing'
            };
            return tailTypes[type] || 'standard';
        }
        
        // 获取鱼鳍类型
        function getFinType(type) {
            const finTypes = {
                shark: 'sharp',
                loach: 'small',
                grass_carp: 'standard',
                whale: 'large',
                crucian_carp: 'rounded',
                bighead_carp: 'large',
                goldfish: 'flowing'
            };
            return finTypes[type] || 'standard';
        }
        
        // 更新鱼类生成（确保池塘中始终保持10条鱼）
        function updateFishSpawning(deltaTime) {
            // 检查当前活跃鱼类数量，如果少于10条则补充
            const activeFishCount = fishes.filter(fish => !fish.isCaught).length;
            if (activeFishCount < 10) {
                const needToSpawn = 10 - activeFishCount;
                for (let i = 0; i < needToSpawn; i++) {
                    spawnFish();
                }
                debugLog(`池塘鱼数不足，已补充${needToSpawn}条鱼，当前池塘鱼数: ${fishes.length}`, 'info');
            }
        }
        
        // 更新和渲染鱼类
        function updateAndRenderFishes(deltaTime) {
            for (let i = fishes.length - 1; i >= 0; i--) {
                const fish = fishes[i];
                
                // 如果鱼被捕获，跳过位置更新
                if (!fish.isCaught) {
                    // 更新鱼类位置
                    fish.x += fish.speed * fish.direction * deltaTime;
                    fish.animationTime += deltaTime;
                }
                
                // 检查边界，移除超出屏幕的鱼（但不移除被捕获的鱼）
                if (!fish.isCaught && (fish.x < -fish.width || fish.x > canvas.width + fish.width)) {
                    fishes.splice(i, 1);
                    // 立即生成一条新鱼以保持池塘数量恒定
                    spawnFish();
                    debugLog(`鱼游出边界，已补充新鱼，池塘鱼数: ${fishes.length}`, 'info');
                    continue;
                }
                
                // 只渲染未被捕获的鱼，被捕获的鱼由Cat对象渲染
                if (!fish.isCaught) {
                    renderFish(fish);
                }
            }
        }
        
        // 渲染单条鱼
        function renderFish(fish) {
            ctx.save();
            
            // 更新发光效果
            if (fish.glowEffect) {
                fish.glowIntensity = 0.5 + Math.sin(fish.animationTime * 3) * 0.3;
            }
            
            // 移动到鱼的位置
            ctx.translate(fish.x + fish.width / 2, fish.y + fish.height / 2);
            
            // 如果向左游，翻转鱼
            if (fish.direction < 0) {
                ctx.scale(-1, 1);
            }
            
            // 添加游泳动画
            const swimOffset = Math.sin(fish.animationTime * 3) * 2;
            const tailWave = Math.sin(fish.animationTime * 4) * 5;
            
            // 绘制发光效果（稀有鱼）
            if (fish.glowEffect) {
                drawFishGlow(fish);
            }
            
            // 绘制鱼身
            drawFishBody(fish, swimOffset);
            
            // 绘制鱼尾
            drawFishTail(fish, tailWave);
            
            // 绘制鱼鳍
            drawFishFins(fish, swimOffset);
            
            // 绘制鱼眼
            drawFishEyes(fish);
            
            // 绘制图案
            drawFishPattern(fish);
            
            ctx.restore();
        }
        
        // 绘制鱼类发光效果
        function drawFishGlow(fish) {
            ctx.save();
            ctx.globalAlpha = fish.glowIntensity * 0.6;
            
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, fish.width);
            gradient.addColorStop(0, fish.color);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, fish.width * 0.8, fish.height * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // 绘制鱼身（根据类型选择绘制方式）
        function drawFishBody(fish, swimOffset) {
            ctx.save();
            
            // 根据鱼类类型使用特殊绘制
            if (fish.type === 'shark') {
                // 鲨鱼流线型鱼身
                const bodyGradient = ctx.createLinearGradient(-fish.width/2, swimOffset - fish.height/2, fish.width/2, swimOffset + fish.height/2);
                bodyGradient.addColorStop(0, fish.color);
                bodyGradient.addColorStop(0.3, fish.secondaryColor);
                bodyGradient.addColorStop(1, darkenColor(fish.color, 0.2));
                ctx.fillStyle = bodyGradient;
                
                // 绘制流线型鲨鱼身体
                ctx.beginPath();
                ctx.moveTo(-fish.width/2, swimOffset);
                ctx.quadraticCurveTo(-fish.width/3, swimOffset - fish.height/2, fish.width/4, swimOffset - fish.height/3);
                ctx.quadraticCurveTo(fish.width/2, swimOffset, fish.width/4, swimOffset + fish.height/3);
                ctx.quadraticCurveTo(-fish.width/3, swimOffset + fish.height/2, -fish.width/2, swimOffset);
                ctx.fill();
                
                // 移除轮廓线条
            } else if (fish.type === 'loach') {
                // 泥鳅细长身体
                ctx.fillStyle = fish.color;
                ctx.beginPath();
                ctx.ellipse(0, swimOffset, fish.width / 2, fish.height / 3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 添加泥鳅特有的条纹
                ctx.strokeStyle = darkenColor(fish.color, 0.3);
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-fish.width/3 + i * fish.width/6, swimOffset - fish.height/4);
                    ctx.lineTo(-fish.width/3 + i * fish.width/6, swimOffset + fish.height/4);
                    ctx.stroke();
                }
            } else if (fish.type === 'whale') {
                // 鲸鱼巨大身体
                const whaleGradient = ctx.createLinearGradient(0, swimOffset - fish.height/2, 0, swimOffset + fish.height/2);
                whaleGradient.addColorStop(0, fish.color);
                whaleGradient.addColorStop(0.5, lightenColor(fish.color, 0.2));
                whaleGradient.addColorStop(1, darkenColor(fish.color, 0.2));
                ctx.fillStyle = whaleGradient;
                
                ctx.beginPath();
                ctx.ellipse(0, swimOffset, fish.width / 2, fish.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 鲸鱼腹部白色
                ctx.fillStyle = '#F0F8FF';
                ctx.beginPath();
                ctx.ellipse(0, swimOffset + fish.height/4, fish.width / 3, fish.height / 4, 0, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // 原来的鱼身绘制方式
                ctx.fillStyle = fish.color;
                ctx.beginPath();
                ctx.ellipse(0, swimOffset, fish.width / 2, fish.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 添加渐变效果
                const gradient = ctx.createRadialGradient(0, swimOffset - fish.height/4, 0, 0, swimOffset, fish.width/2);
                gradient.addColorStop(0, lightenColor(fish.color, 0.3));
                gradient.addColorStop(1, fish.color);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // 简化的鱼身光泽效果
        function drawBodyShine(fish, swimOffset) {
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(-fish.width/6, swimOffset - fish.height/6, fish.width/8, fish.height/8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // 颜色辅助函数
        function lightenColor(color, amount) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(255 * amount);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }
        
        function darkenColor(color, amount) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(255 * amount);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            return '#' + (0x1000000 + (R > 0 ? R : 0) * 0x10000 +
                (G > 0 ? G : 0) * 0x100 + (B > 0 ? B : 0)).toString(16).slice(1);
        }
        
        // 绘制真实鱼尾
        function drawFishTail(fish, tailWave) {
            ctx.save();
            
            if (fish.type === 'shark') {
                // 鲨鱼月牙形尾巴
                ctx.fillStyle = fish.color;
                const tailX = -fish.width / 2;
                const tailSize = fish.width * 0.5;
                
                ctx.beginPath();
                // 上半部分
                ctx.moveTo(tailX, tailWave);
                ctx.quadraticCurveTo(tailX - tailSize * 0.8, tailWave - tailSize * 0.6, tailX - tailSize, tailWave - tailSize * 0.3);
                ctx.quadraticCurveTo(tailX - tailSize * 0.6, tailWave - tailSize * 0.1, tailX - tailSize * 0.3, tailWave);
                // 下半部分
                ctx.quadraticCurveTo(tailX - tailSize * 0.6, tailWave + tailSize * 0.1, tailX - tailSize, tailWave + tailSize * 0.3);
                ctx.quadraticCurveTo(tailX - tailSize * 0.8, tailWave + tailSize * 0.6, tailX, tailWave);
                ctx.fill();
                
                // 移除轮廓线条
            } else {
                // 原来的鱼尾绘制方式
                ctx.fillStyle = fish.color;
                const tailX = -fish.width / 2;
                const tailSize = fish.width * 0.3;
                
                ctx.beginPath();
                ctx.moveTo(tailX, tailWave);
                ctx.quadraticCurveTo(tailX - tailSize, tailWave - tailSize/2, tailX - tailSize * 0.8, tailWave);
                ctx.quadraticCurveTo(tailX - tailSize, tailWave + tailSize/2, tailX, tailWave);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // 各种鱼尾形状的绘制函数
        function drawForkedTail(tailX, tailWave, tailSize, fishHeight) {
            ctx.moveTo(tailX, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.6, tailWave - fishHeight * 0.4, tailX - tailSize, tailWave - fishHeight * 0.3);
            ctx.quadraticCurveTo(tailX - tailSize * 0.8, tailWave - fishHeight * 0.1, tailX - tailSize * 0.6, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.8, tailWave + fishHeight * 0.1, tailX - tailSize, tailWave + fishHeight * 0.3);
            ctx.quadraticCurveTo(tailX - tailSize * 0.6, tailWave + fishHeight * 0.4, tailX, tailWave);
        }
        
        function drawBroadTail(tailX, tailWave, tailSize, fishHeight) {
            ctx.moveTo(tailX, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.7, tailWave - fishHeight * 0.5, tailX - tailSize * 0.9, tailWave - fishHeight * 0.4);
            ctx.quadraticCurveTo(tailX - tailSize, tailWave, tailX - tailSize * 0.9, tailWave + fishHeight * 0.4);
            ctx.quadraticCurveTo(tailX - tailSize * 0.7, tailWave + fishHeight * 0.5, tailX, tailWave);
        }
        
        function drawFlowingTail(tailX, tailWave, tailSize, fishHeight) {
            ctx.moveTo(tailX, tailWave);
            ctx.bezierCurveTo(
                tailX - tailSize * 0.3, tailWave - fishHeight * 0.3,
                tailX - tailSize * 0.8, tailWave - fishHeight * 0.2,
                tailX - tailSize * 1.1, tailWave
            );
            ctx.bezierCurveTo(
                tailX - tailSize * 0.8, tailWave + fishHeight * 0.2,
                tailX - tailSize * 0.3, tailWave + fishHeight * 0.3,
                tailX, tailWave
            );
        }
        
        function drawTriangularTail(tailX, tailWave, tailSize, fishHeight) {
            ctx.moveTo(tailX, tailWave);
            ctx.lineTo(tailX - tailSize * 1.2, tailWave - fishHeight * 0.2);
            ctx.quadraticCurveTo(tailX - tailSize * 1.3, tailWave, tailX - tailSize * 1.2, tailWave + fishHeight * 0.2);
            ctx.lineTo(tailX, tailWave);
        }
        
        function drawRoundedTail(tailX, tailWave, tailSize, fishHeight) {
            ctx.moveTo(tailX, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.5, tailWave - fishHeight * 0.3, tailX - tailSize * 0.8, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.5, tailWave + fishHeight * 0.3, tailX, tailWave);
        }
        
        function drawStandardTail(tailX, tailWave, tailSize, fishHeight) {
            ctx.moveTo(tailX, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.6, tailWave - fishHeight * 0.35, tailX - tailSize * 0.9, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.6, tailWave + fishHeight * 0.35, tailX, tailWave);
        }
        
        // 绘制鱼尾纹理
        function drawTailTexture(fish, tailX, tailWave, tailSize) {
            ctx.save();
            ctx.strokeStyle = darkenColor(fish.secondaryColor, 0.4);
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.6;
            
            // 绘制鱼尾的放射状纹理
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(tailX - tailSize * 0.2, tailWave);
                ctx.lineTo(tailX - tailSize * 0.8, tailWave + (i - 1) * fish.height * 0.15);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // 绘制真实鱼鳍
        function drawFishFins(fish, swimOffset) {
            ctx.save();
            
            const finOffset = Math.sin(fish.animationTime * 2.5) * 2;
            
            if (fish.type === 'shark') {
                // 鲨鱼尖锐鱼鳍
                ctx.fillStyle = fish.secondaryColor;
                const finSize = fish.width * 0.2;
                
                // 背鳍 - 三角形
                ctx.beginPath();
                ctx.moveTo(-fish.width * 0.1, swimOffset - fish.height * 0.3 + finOffset);
                ctx.lineTo(0, swimOffset - fish.height * 0.6 + finOffset);
                ctx.lineTo(fish.width * 0.1, swimOffset - fish.height * 0.3 + finOffset);
                ctx.closePath();
                ctx.fill();
                
                // 腹鳍 - 小三角形
                ctx.beginPath();
                ctx.moveTo(-fish.width * 0.05, swimOffset + fish.height * 0.25 - finOffset);
                ctx.lineTo(0, swimOffset + fish.height * 0.4 - finOffset);
                ctx.lineTo(fish.width * 0.05, swimOffset + fish.height * 0.25 - finOffset);
                ctx.closePath();
                ctx.fill();
                
                // 胸鳍 - 尖锐形状
                ctx.beginPath();
                ctx.moveTo(fish.width * 0.05, swimOffset + finOffset * 0.5);
                ctx.lineTo(fish.width * 0.2, swimOffset - fish.height * 0.1 + finOffset * 0.5);
                ctx.lineTo(fish.width * 0.15, swimOffset + fish.height * 0.1 + finOffset * 0.5);
                ctx.closePath();
                ctx.fill();
            } else if (fish.type === 'loach') {
                // 泥鳅小鱼鳍
                ctx.fillStyle = fish.secondaryColor;
                const finSize = fish.width * 0.1;
                
                // 小背鳍
                ctx.beginPath();
                ctx.arc(0, swimOffset - fish.height * 0.2 + finOffset, finSize * 0.5, 0, Math.PI, true);
                ctx.fill();
                
                // 小腹鳍
                ctx.beginPath();
                ctx.arc(0, swimOffset + fish.height * 0.15 - finOffset, finSize * 0.3, Math.PI, 0, true);
                ctx.fill();
            } else if (fish.type === 'whale') {
                // 鲸鱼大鱼鳍
                ctx.fillStyle = fish.secondaryColor;
                const finSize = fish.width * 0.3;
                
                // 大背鳍
                ctx.beginPath();
                ctx.moveTo(-fish.width * 0.2, swimOffset - fish.height * 0.4 + finOffset);
                ctx.quadraticCurveTo(0, swimOffset - fish.height * 0.6 + finOffset, fish.width * 0.2, swimOffset - fish.height * 0.4 + finOffset);
                ctx.quadraticCurveTo(0, swimOffset - fish.height * 0.3, -fish.width * 0.2, swimOffset - fish.height * 0.4 + finOffset);
                ctx.fill();
                
                // 大胸鳍
                ctx.beginPath();
                ctx.ellipse(fish.width * 0.1, swimOffset + finOffset * 0.5, finSize * 0.8, finSize * 0.4, -Math.PI / 6, 0, 2 * Math.PI);
                ctx.fill();
            } else {
                // 根据鱼鳍类型绘制
                ctx.fillStyle = fish.secondaryColor;
                const finSize = fish.width * 0.2;
                
                switch (fish.finType) {
                    case 'sharp':
                        drawSharpFins(fish, finSize, swimOffset, finOffset);
                        break;
                    case 'small':
                        drawSmallFins(fish, finSize, swimOffset, finOffset);
                        break;
                    case 'large':
                        drawLargeFins(fish, finSize, swimOffset, finOffset);
                        break;
                    case 'rounded':
                        drawRoundedFins(fish, finSize, swimOffset, finOffset);
                        break;
                    case 'flowing':
                        drawFlowingFins(fish, finSize, swimOffset, finOffset);
                        break;
                    case 'standard':
                    default:
                        drawStandardFins(fish, finSize, swimOffset, finOffset);
                        break;
                }
            }
            
            ctx.restore();
        }
        
        // 各种鱼鳍形状的绘制函数
        function drawLargeFins(fish, finSize, swimOffset, finOffset) {
            // 背鳍
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.2, -fish.height * 0.4 + swimOffset + finOffset);
            ctx.quadraticCurveTo(0, -fish.height * 0.6 + swimOffset + finOffset, fish.width * 0.2, -fish.height * 0.4 + swimOffset + finOffset);
            ctx.quadraticCurveTo(0, -fish.height * 0.3 + swimOffset, -fish.width * 0.2, -fish.height * 0.4 + swimOffset + finOffset);
            ctx.fill();
            
            // 腹鳍
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.1, fish.height * 0.3 + swimOffset - finOffset);
            ctx.quadraticCurveTo(0, fish.height * 0.5 + swimOffset - finOffset, fish.width * 0.1, fish.height * 0.3 + swimOffset - finOffset);
            ctx.quadraticCurveTo(0, fish.height * 0.25 + swimOffset, -fish.width * 0.1, fish.height * 0.3 + swimOffset - finOffset);
            ctx.fill();
        }
        
        function drawFlowingFins(fish, finSize, swimOffset, finOffset) {
            // 背鳍
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.3, -fish.height * 0.3 + swimOffset + finOffset);
            ctx.bezierCurveTo(
                -fish.width * 0.1, -fish.height * 0.7 + swimOffset + finOffset,
                fish.width * 0.1, -fish.height * 0.7 + swimOffset + finOffset,
                fish.width * 0.3, -fish.height * 0.3 + swimOffset + finOffset
            );
            ctx.quadraticCurveTo(0, -fish.height * 0.25 + swimOffset, -fish.width * 0.3, -fish.height * 0.3 + swimOffset + finOffset);
            ctx.fill();
            
            // 腹鳍
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.2, fish.height * 0.25 + swimOffset - finOffset);
            ctx.quadraticCurveTo(0, fish.height * 0.45 + swimOffset - finOffset, fish.width * 0.2, fish.height * 0.25 + swimOffset - finOffset);
            ctx.quadraticCurveTo(0, fish.height * 0.2 + swimOffset, -fish.width * 0.2, fish.height * 0.25 + swimOffset - finOffset);
            ctx.fill();
        }
        
        function drawPointedFins(fish, finSize, swimOffset, finOffset) {
            // 背鳍（天使鱼特有的高背鳍）
            ctx.beginPath();
            ctx.moveTo(0, -fish.height * 0.3 + swimOffset + finOffset);
            ctx.lineTo(-fish.width * 0.1, -fish.height * 0.8 + swimOffset + finOffset);
            ctx.lineTo(fish.width * 0.1, -fish.height * 0.8 + swimOffset + finOffset);
            ctx.closePath();
            ctx.fill();
            
            // 腹鳍（天使鱼特有的长腹鳍）
            ctx.beginPath();
            ctx.moveTo(0, fish.height * 0.3 + swimOffset - finOffset);
            ctx.lineTo(-fish.width * 0.05, fish.height * 0.7 + swimOffset - finOffset);
            ctx.lineTo(fish.width * 0.05, fish.height * 0.7 + swimOffset - finOffset);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawRoundedFins(fish, finSize, swimOffset, finOffset) {
            // 背鳍
            ctx.beginPath();
            ctx.arc(0, -fish.height * 0.35 + swimOffset + finOffset, finSize * 0.8, 0, Math.PI, true);
            ctx.fill();
            
            // 腹鳍
            ctx.beginPath();
            ctx.arc(0, fish.height * 0.3 + swimOffset - finOffset, finSize * 0.6, Math.PI, 0, true);
            ctx.fill();
        }
        
        function drawDelicateFins(fish, finSize, swimOffset, finOffset) {
            // 多段式背鳍
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                const x = (i - 1) * fish.width * 0.15;
                ctx.ellipse(x, -fish.height * 0.35 + swimOffset + finOffset, finSize * 0.4, finSize * 0.6, 0, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // 腹鳍
            ctx.beginPath();
            ctx.ellipse(0, fish.height * 0.3 + swimOffset - finOffset, finSize * 0.7, finSize * 0.4, 0, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        function drawStandardFins(fish, finSize, swimOffset, finOffset) {
            // 背鳍
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.15, -fish.height * 0.3 + swimOffset + finOffset);
            ctx.quadraticCurveTo(0, -fish.height * 0.5 + swimOffset + finOffset, fish.width * 0.15, -fish.height * 0.3 + swimOffset + finOffset);
            ctx.quadraticCurveTo(0, -fish.height * 0.25 + swimOffset, -fish.width * 0.15, -fish.height * 0.3 + swimOffset + finOffset);
            ctx.fill();
            
            // 腹鳍
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.1, fish.height * 0.25 + swimOffset - finOffset);
            ctx.quadraticCurveTo(0, fish.height * 0.4 + swimOffset - finOffset, fish.width * 0.1, fish.height * 0.25 + swimOffset - finOffset);
            ctx.quadraticCurveTo(0, fish.height * 0.2 + swimOffset, -fish.width * 0.1, fish.height * 0.25 + swimOffset - finOffset);
            ctx.fill();
        }
        
        function drawSmallFins(fish, finSize, swimOffset, finOffset) {
            // 小背鳍
            ctx.beginPath();
            ctx.arc(0, -fish.height * 0.25 + swimOffset + finOffset, finSize * 0.4, 0, Math.PI, true);
            ctx.fill();
            
            // 小腹鳍
            ctx.beginPath();
            ctx.arc(0, fish.height * 0.2 + swimOffset - finOffset, finSize * 0.3, Math.PI, 0, true);
            ctx.fill();
        }
        
        function drawSharpFins(fish, finSize, swimOffset, finOffset) {
            // 尖锐背鳍
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.1, swimOffset - fish.height * 0.3 + finOffset);
            ctx.lineTo(0, swimOffset - fish.height * 0.6 + finOffset);
            ctx.lineTo(fish.width * 0.1, swimOffset - fish.height * 0.3 + finOffset);
            ctx.closePath();
            ctx.fill();
            
            // 尖锐腹鳍
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.05, swimOffset + fish.height * 0.25 - finOffset);
            ctx.lineTo(0, swimOffset + fish.height * 0.4 - finOffset);
            ctx.lineTo(fish.width * 0.05, swimOffset + fish.height * 0.25 - finOffset);
            ctx.closePath();
            ctx.fill();
        }
        
        // 绘制胸鳍
        function drawPectoralFins(fish, finSize, swimOffset, finOffset) {
            ctx.save();
            ctx.globalAlpha = 0.8;
            
            // 左胸鳍
            ctx.beginPath();
            ctx.ellipse(-fish.width * 0.1, swimOffset + finOffset * 0.5, finSize * 0.5, finSize * 0.3, Math.PI / 3, 0, 2 * Math.PI);
            ctx.fill();
            
            // 右胸鳍
            ctx.beginPath();
            ctx.ellipse(fish.width * 0.1, swimOffset - finOffset * 0.5, finSize * 0.5, finSize * 0.3, -Math.PI / 3, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.restore();
        }
        
        // 绘制鱼眼
        function drawFishEyes(fish) {
            // 眼白
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(fish.width / 4, -fish.height / 6, fish.width * 0.08, 0, Math.PI * 2);
            ctx.fill();
            
            // 眼珠
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(fish.width / 4 + 1, -fish.height / 6, fish.width * 0.04, 0, Math.PI * 2);
            ctx.fill();
            
            // 眼睛高光
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(fish.width / 4 + 2, -fish.height / 6 - 1, fish.width * 0.02, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // 绘制鱼类图案
        function drawFishPattern(fish) {
            ctx.save();
            
            switch (fish.pattern) {
                case 'stripes':
                    // 条纹图案 - 改为垂直条纹
                    ctx.fillStyle = fish.secondaryColor;
                    for (let i = 0; i < 3; i++) {
                        const x = -fish.width / 3 + i * fish.width / 4;
                        const stripeWidth = fish.width * 0.08;
                        ctx.fillRect(x - stripeWidth / 2, -fish.height / 2, stripeWidth, fish.height);
                    }
                    break;
                case 'scales':
                    // 鱼鳞图案 - 移除白色线条，改为填充小圆点
                    ctx.fillStyle = fish.secondaryColor;
                    ctx.globalAlpha = 0.3;
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            if (i === 0 && j === 0) continue; // 跳过中心点
                            ctx.beginPath();
                            ctx.arc(i * fish.width * 0.15, j * fish.height * 0.15, fish.width * 0.03, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    ctx.globalAlpha = 1;
                    break;
                case 'bands':
                    // 小丑鱼图案 - 移除白色条带
                    // 不绘制任何图案，保持纯色
                    break;
                case 'sparkle':
                    // 闪烁效果（稀有鱼）
                    ctx.fillStyle = '#FFFFFF';
                    for (let i = 0; i < 5; i++) {
                        const x = (Math.random() - 0.5) * fish.width * 0.8;
                        const y = (Math.random() - 0.5) * fish.height * 0.8;
                        const size = Math.random() * 2 + 1;
                        const alpha = Math.sin(fish.animationTime * 5 + i) * 0.5 + 0.5;
                        
                        ctx.save();
                        ctx.globalAlpha = alpha;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    break;
            }
            
            ctx.restore();
        }
        
        // 检查钓鱼碰撞
         function checkFishingCollisions() {
             if (!cat || !cat.isFishingActive()) return;
             
             const hookRect = cat.getHookCollisionRect();
             
             // 检查是否已经抓到鱼
             if (cat.fishingRod && cat.fishingRod.caughtFish) return;
             
             // 检测与鱼类的碰撞
             for (let i = 0; i < fishes.length; i++) {
                 const fish = fishes[i];
                 if (!fish.isActive) continue;
                 
                 if (checkCollision(hookRect, fish)) {
                     // 捕获鱼类
                     fish.isActive = false;
                     fish.isCaught = true;
                     
                     // 调用Cat的setCaughtFish方法
                     if (cat.setCaughtFish) {
                         cat.setCaughtFish(fish);
                     } else {
                         cat.fishingRod.caughtFish = fish;
                     }
                     
                     // 如果正在下降，立即开始收杆
                     if (cat.fishingRod.isDropping) {
                         cat.startReeling();
                     }
                     
                     caughtFishCount++; // 增加钓鱼计数
                     
                     // 播放钓鱼成功音效
                     playCatchSound();
                     
                     // 从数组中移除被捕获的鱼
                     fishes.splice(i, 1);
                     
                     // 立即生成一条新鱼以保持鱼塘数量恒定
                     spawnFish();
                     
                     debugLog(`捕获了一条${fish.type}鱼！总计: ${caughtFishCount}条，池塘鱼数: ${fishes.length}`, 'success');
                     break;
                 }
             }
         }
         
         // 简单的矩形碰撞检测
         function checkCollision(rect1, rect2) {
             return rect1.x < rect2.x + rect2.width &&
                    rect1.x + rect1.width > rect2.x &&
                    rect1.y < rect2.y + rect2.height &&
                    rect1.y + rect1.height > rect2.y;
         }
         
         // 更新游戏时间
         function updateGameTimer(deltaTime) {
             if (!isGameActive) return;
             
             gameTimer += deltaTime;
             const remainingTime = Math.max(0, gameTime - gameTimer);
             
             // 时间到了，结束游戏
             if (remainingTime <= 0) {
                 isGameActive = false;
                 debugLog('游戏时间结束！', 'warning');
             }
         }
         
         // 获取格式化的剩余时间
         function getFormattedTime() {
             const remainingTime = Math.max(0, gameTime - gameTimer);
             const minutes = Math.floor(remainingTime / 60);
             const seconds = Math.floor(remainingTime % 60);
             return `${minutes}:${seconds.toString().padStart(2, '0')}`;
         }
         
         // 渲染调试信息
         function renderDebugInfo() {
             // 红色框区域显示：钓鱼数量和倒计时
             // 左上角显示钓鱼数量
             ctx.fillStyle = isGameActive ? '#000' : '#FF6B6B';
             ctx.font = 'bold 18px Arial';
             ctx.textAlign = 'left';
             ctx.fillText(`钓鱼数量: ${caughtFishCount}`, 20, 30);
             
             // 右上角显示倒计时
             ctx.textAlign = 'right';
             ctx.fillText(`时间: ${getFormattedTime()}`, canvas.width - 20, 30);
             

             
             // 游戏结束提示已移除
         }
        
        function testFishing() {
            if (!cat) {
                debugLog('小猫对象未初始化', 'error');
                return;
            }
            
            if (!isGameActive) {
                debugLog('游戏已结束，无法钓鱼', 'warning');
                return;
            }
            
            debugLog('测试钓鱼功能...', 'info');
            debugLog(`当前池塘中有 ${fishes.length} 条鱼`, 'info');
            
            try {
                const canFish = cat.canFish();
                debugLog(`小猫是否可以钓鱼: ${canFish}`, canFish ? 'success' : 'warning');
                
                if (canFish) {
                    const result = cat.startFishing();
                    debugLog(`开始钓鱼结果: ${result}`, result ? 'success' : 'error');
                    
                    if (result) {
                        playCastSound(); // 播放投掷鱼竿音效
                        debugLog('钓鱼功能正常工作！', 'success');
                    }
                } else {
                    debugLog('小猫当前无法钓鱼（可能正在钓鱼中）', 'warning');
                }
                
            } catch (error) {
                debugLog(`钓鱼测试失败: ${error.message}`, 'error');
                console.error('钓鱼测试错误:', error);
            }
        }
        
        function testReeling() {
            if (!cat) {
                debugLog('小猫对象未初始化', 'error');
                return;
            }
            
            if (!isGameActive) {
                debugLog('游戏已结束，无法收杆', 'warning');
                return;
            }
            
            debugLog('测试收杆功能...', 'info');
            
            try {
                const isFishing = cat.isFishingActive();
                debugLog(`小猫是否正在钓鱼: ${isFishing}`, isFishing ? 'success' : 'warning');
                
                if (isFishing) {
                    cat.startReeling();
                    playReelSound(); // 播放收杆音效
                    debugLog('开始收杆', 'success');
                } else {
                    debugLog('小猫当前没有在钓鱼，无法收杆', 'warning');
                }
                
            } catch (error) {
                debugLog(`收杆测试失败: ${error.message}`, 'error');
                console.error('收杆测试错误:', error);
            }
        }
        
        function startGame() {
            debugLog('开始游戏...', 'info');
            
            // 重置游戏状态
            gameTimer = 0;
            isGameActive = true;
            caughtFishCount = 0;
            
            // 清空并重新生成鱼类
            fishes = [];
            fishSpawnTimer = 0;
            spawnInitialFishes();
            
            // 重置小猫状态
            if (cat) {
                cat.resetFishingRod();
                cat.mood = 'happy';
                cat.currentAnimation = 'idle';
            }
            
            // 启动背景音乐
            if (!window.bgmAudio || window.bgmAudio.paused) {
                playBackgroundMusic();
            }
            
            // 更新按钮状态
            const startButton = document.getElementById('startButton');
            if (startButton) {
                startButton.textContent = '🔄 重新开始';
                startButton.style.background = '#FF9500';
            }
            
            debugLog('游戏开始！点击画布进行钓鱼', 'success');
        }
        
        function resetGame() {
            debugLog('重置游戏...', 'info');
            
            // 重置游戏时间
            gameTimer = 0;
            isGameActive = true;
            
            // 重置钓鱼计数
            caughtFishCount = 0;
            
            // 清空鱼类
            fishes = [];
            fishSpawnTimer = 0;
            
            // 重置小猫状态
            if (cat) {
                cat.resetFishingRod();
                cat.mood = 'happy';
                cat.currentAnimation = 'idle';
            }
            
            // 确保背景音乐正在播放
            if (!window.bgmAudio || window.bgmAudio.paused) {
                playBackgroundMusic();
            }
            
            // 重新生成初始鱼类
            spawnInitialFishes();
            
            debugLog('游戏重置完成！', 'success');
        }
        
        function checkCatState() {
            if (!cat) {
                debugLog('小猫对象未初始化', 'error');
                return;
            }
            
            debugLog('检查小猫状态...', 'info');
            
            try {
                debugLog(`小猫位置: (${cat.x}, ${cat.y})`, 'info');
                debugLog(`鱼竿对象存在: ${!!cat.fishingRod}`, cat.fishingRod ? 'success' : 'error');
                
                if (cat.fishingRod) {
                    debugLog(`鱼竿状态: ${cat.getFishingRodState()}`, 'info');
                    debugLog(`正在下降: ${cat.fishingRod.isDropping}`, 'info');
                    debugLog(`正在收杆: ${cat.fishingRod.isReeling}`, 'info');
                }
                
                debugLog(`动画管理器存在: ${!!cat.animationManager}`, cat.animationManager ? 'success' : 'error');
                debugLog(`当前心情: ${cat.mood}`, 'info');
                debugLog(`当前动画: ${cat.currentAnimation}`, 'info');
                
            } catch (error) {
                debugLog(`状态检查失败: ${error.message}`, 'error');
                console.error('状态检查错误:', error);
            }
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', () => {
            debugLog('页面加载完成，开始初始化测试环境', 'info');
            setTimeout(initTest, 100);
            
            // 添加用户交互监听器来启动音频
            document.addEventListener('click', function enableAudio() {
                if (!window.audioEnabled) {
                    window.audioEnabled = true;
                    playBackgroundMusic();
                    debugLog('用户交互检测到，尝试启动背景音乐', 'info');
                    // 移除监听器，只需要触发一次
                    document.removeEventListener('click', enableAudio);
                }
            }, { once: true });
        });
        
        // 点击画布测试钓鱼
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            if (canvas) {
                canvas.addEventListener('click', (event) => {
                    debugLog('画布被点击，测试钓鱼交互', 'info');
                    
                    // 首次点击时启动背景音乐
                    if (window.musicReady && (!window.bgmAudio || window.bgmAudio.paused)) {
                        playBackgroundMusic();
                    }
                    
                    if (!isGameActive) {
                        debugLog('游戏已结束，点击无效', 'warning');
                        return;
                    }
                    
                    if (cat) {
                        if (cat.canFish()) {
                            testFishing();
                        } else if (cat.isFishingActive()) {
                            testReeling();
                        }
                    }
                });
            }
        });
    </script>
</body>
</html>