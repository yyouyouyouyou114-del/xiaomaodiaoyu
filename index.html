<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é’“é±¼åŠŸèƒ½æµ‹è¯•</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #74b9ff, #0984e3);
        }
        
        #gameContainer {
            position: relative;
            background: transparent;
            border-radius: 0;
            padding: 0;
            box-shadow: none;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        
        #gameCanvas {
            border: none;
            border-radius: 0;
            display: block;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
        }
        
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
            text-align: center;
            pointer-events: none;
        }
        
        .game-overlay > * {
            pointer-events: auto;
        }
        
        .controls {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            margin: 0;
            display: flex;
            flex-direction: row;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            white-space: nowrap;
        }
        
        button:hover {
            background: #45a049;
        }
        
        h1 {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            margin: 0;
            padding: 0;
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 11;
        }
        
        html {
            margin: 0;
            padding: 0;
            height: 100%;
        }

    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        
        <h1><svg width="48" height="48" viewBox="0 0 64 64" style="vertical-align: middle; margin-right: 8px;">
            <!-- çŒ«å’ªå¤´éƒ¨ -->
            <circle cx="32" cy="28" r="18" fill="#FF8C69"/>
            
            <!-- çŒ«å’ªè€³æœµ -->
            <polygon points="20,16 26,6 30,16" fill="#E55555"/>
            <polygon points="34,16 38,6 44,16" fill="#E55555"/>
            
            <!-- è€³æœµå†…éƒ¨ -->
            <polygon points="22,15 26,9 28,15" fill="#FFB6C1"/>
            <polygon points="36,15 38,9 42,15" fill="#FFB6C1"/>
            
            <!-- çŒ«å’ªçœ¼ç› -->
            <ellipse cx="26" cy="24" rx="3" ry="4" fill="#000"/>
            <ellipse cx="38" cy="24" rx="3" ry="4" fill="#000"/>
            
            <!-- çœ¼ç›é«˜å…‰ -->
            <circle cx="27" cy="22" r="1" fill="#FFF"/>
            <circle cx="39" cy="22" r="1" fill="#FFF"/>
            
            <!-- é¼»å­ -->
            <polygon points="32,30 30,34 34,34" fill="#FF69B4"/>
            
            <!-- å˜´å·´ -->
            <path d="M32,34 Q26,36 22,32" stroke="#000" stroke-width="1.5" fill="none"/>
            <path d="M32,34 Q38,36 42,32" stroke="#000" stroke-width="1.5" fill="none"/>
            
            <!-- èƒ¡é¡» -->
            <line x1="16" y1="26" x2="8" y2="24" stroke="#000" stroke-width="1"/>
            <line x1="16" y1="30" x2="8" y2="30" stroke="#000" stroke-width="1"/>
            <line x1="16" y1="34" x2="8" y2="36" stroke="#000" stroke-width="1"/>
            <line x1="48" y1="26" x2="56" y2="24" stroke="#000" stroke-width="1"/>
            <line x1="48" y1="30" x2="56" y2="30" stroke="#000" stroke-width="1"/>
            <line x1="48" y1="34" x2="56" y2="36" stroke="#000" stroke-width="1"/>
            
            <!-- çŒ«å’ªèº«ä½“ -->
            <ellipse cx="32" cy="48" rx="12" ry="8" fill="#FF8C69"/>
            
            <!-- å‰è…¿ -->
            <rect x="24" y="52" width="4" height="8" fill="#FF8C69"/>
            <rect x="36" y="52" width="4" height="8" fill="#FF8C69"/>
            
            <!-- çˆªå­ -->
            <circle cx="26" cy="60" r="2" fill="#E55555"/>
            <circle cx="38" cy="60" r="2" fill="#E55555"/>
        </svg> å°çŒ«é’“é±¼</h1>

        <div class="controls">
            <button onclick="startGame()" id="startButton" style="background: #4CAF50; font-weight: bold;">ğŸ® å¼€å§‹æ¸¸æˆ</button>
            <button onclick="toggleBackgroundMusic()" id="musicToggle" style="background: #FF6B6B; font-weight: bold;">ğŸµ æ’­æ”¾éŸ³ä¹</button>
        </div>
        

    </div>
    
    <!-- æ¸¸æˆè„šæœ¬ -->
    <script src="src/adapter.js"></script>
    <script src="src/main.js"></script>
    <script src="src/audio/AudioManager.js"></script>
    <script src="src/animation/AnimationManager.js"></script>
    <script src="src/effects/ParticleSystem.js"></script>
    <script src="src/entities/Cat.js?v=20250131"></script>
<script src="src/entities/Fish.js?v=20250131"></script>
<script src="src/entities/Obstacle.js?v=20250131"></script>
<script src="src/entities/PowerUp.js?v=20250131"></script>
<script src="src/systems/Spawner.js?v=20250131"></script>
<script src="src/systems/CollisionSystem.js?v=20250131"></script>
<script src="src/systems/ScoreSystem.js?v=20250131"></script>
<script src="src/ui/UIManager.js?v=20250131"></script>
<script src="src/scenes/MainMenu.js?v=20250131"></script>
<script src="src/scenes/GameScene.js?v=20250131"></script>
<script src="src/scenes/GameOver.js?v=20250131"></script>
    
    <script>
        let canvas, ctx, cat, animationManager, audioManager, fishes, fishSpawnTimer;
        
        // æ¸¸æˆæ—¶é—´ç®¡ç†
        let gameTime = 90; // 90ç§’ = 1.5åˆ†é’Ÿ
        let gameTimer = 0;
        let isGameActive = true;
        
        // é’“é±¼è®¡æ•°
        let caughtFishCount = 0;
        
        // éŸ³æ•ˆæ’­æ”¾å‡½æ•°
        function playCatchSound() {
            try {
                // ä½¿ç”¨AudioManageræ’­æ”¾é’“é±¼æˆåŠŸéŸ³æ•ˆ
                if (audioManager) {
                    audioManager.playSfx('fishCaught');
                    debugLog('æ’­æ”¾é’“é±¼æˆåŠŸéŸ³æ•ˆ', 'info');
                } else {
                    // å¤‡ç”¨æ–¹æ¡ˆï¼šç›´æ¥æ’­æ”¾éŸ³é¢‘æ–‡ä»¶
                    const catchAudio = new Audio('audio/catch.mp3');
                    catchAudio.volume = 0.7;
                    catchAudio.play().catch(e => {
                        console.log('éŸ³æ•ˆæ’­æ”¾å¤±è´¥:', e);
                    });
                }
            } catch (error) {
                console.log('éŸ³æ•ˆæ’­æ”¾å‡ºé”™:', error);
            }
        }
        
        // æ’­æ”¾æŠ•æ·é±¼ç«¿éŸ³æ•ˆ
        function playCastSound() {
            try {
                if (audioManager) {
                    audioManager.playSfx('cast');
                    debugLog('æ’­æ”¾æŠ•æ·é±¼ç«¿éŸ³æ•ˆ', 'info');
                }
            } catch (error) {
                console.log('æŠ•æ·éŸ³æ•ˆæ’­æ”¾å‡ºé”™:', error);
            }
        }
        
        // æ’­æ”¾æ”¶æ†éŸ³æ•ˆ
        function playReelSound() {
            try {
                if (audioManager) {
                    audioManager.playSfx('reel');
                    debugLog('æ’­æ”¾æ”¶æ†éŸ³æ•ˆ', 'info');
                }
            } catch (error) {
                console.log('æ”¶æ†éŸ³æ•ˆæ’­æ”¾å‡ºé”™:', error);
            }
        }
        
        // ç”ŸæˆåˆæˆèƒŒæ™¯éŸ³ä¹
        function generateBackgroundMusic() {
            try {
                debugLog('å¼€å§‹ç”ŸæˆåˆæˆèƒŒæ™¯éŸ³ä¹...', 'info');
                
                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // åˆ›å»ºä¸€ä¸ªç®€å•çš„æ—‹å¾‹
                const notes = [
                    { freq: 261.63, duration: 0.5 }, // C4
                    { freq: 293.66, duration: 0.5 }, // D4
                    { freq: 329.63, duration: 0.5 }, // E4
                    { freq: 349.23, duration: 0.5 }, // F4
                    { freq: 392.00, duration: 0.5 }, // G4
                    { freq: 440.00, duration: 0.5 }, // A4
                    { freq: 493.88, duration: 0.5 }, // B4
                    { freq: 523.25, duration: 1.0 }  // C5
                ];
                
                const totalDuration = notes.reduce((sum, note) => sum + note.duration, 0);
                const sampleRate = audioContext.sampleRate;
                const bufferLength = sampleRate * totalDuration;
                const buffer = audioContext.createBuffer(1, bufferLength, sampleRate);
                const channelData = buffer.getChannelData(0);
                
                let currentTime = 0;
                
                notes.forEach(note => {
                    const startSample = Math.floor(currentTime * sampleRate);
                    const endSample = Math.floor((currentTime + note.duration) * sampleRate);
                    
                    for (let i = startSample; i < endSample && i < bufferLength; i++) {
                        const t = (i - startSample) / sampleRate;
                        const envelope = Math.exp(-t * 2); // è¡°å‡åŒ…ç»œ
                        channelData[i] += Math.sin(2 * Math.PI * note.freq * t) * envelope * 0.1;
                    }
                    
                    currentTime += note.duration;
                });
                
                debugLog('åˆæˆéŸ³ä¹ç”Ÿæˆå®Œæˆ', 'success');
                return { audioContext, buffer };
                
            } catch (error) {
                debugLog('ç”ŸæˆåˆæˆéŸ³ä¹å¤±è´¥: ' + error.message, 'error');
                return null;
            }
        }
        
        // å‡†å¤‡èƒŒæ™¯éŸ³ä¹ï¼ˆä¸ç«‹å³æ’­æ”¾ï¼‰
        function prepareBackgroundMusic() {
            try {
                if (!window.bgmAudio) {
                    debugLog('å¼€å§‹åˆ›å»ºèƒŒæ™¯éŸ³ä¹å¯¹è±¡...', 'info');
                    
                    // ç”ŸæˆåˆæˆèƒŒæ™¯éŸ³ä¹
                    const musicData = generateBackgroundMusic();
                    
                    if (!musicData) {
                        debugLog('æ— æ³•ç”ŸæˆèƒŒæ™¯éŸ³ä¹', 'error');
                        return;
                    }
                    
                    // åˆ›å»ºéŸ³é¢‘æºèŠ‚ç‚¹
                    const source = musicData.audioContext.createBufferSource();
                    source.buffer = musicData.buffer;
                    source.loop = true; // å¾ªç¯æ’­æ”¾
                    
                    // åˆ›å»ºå¢ç›ŠèŠ‚ç‚¹æ§åˆ¶éŸ³é‡
                    const gainNode = musicData.audioContext.createGain();
                    gainNode.gain.value = 0.3; // è®¾ç½®éŸ³é‡ä¸º30%
                    
                    // è¿æ¥éŸ³é¢‘èŠ‚ç‚¹
                    source.connect(gainNode);
                    gainNode.connect(musicData.audioContext.destination);
                    
                    // ä¿å­˜éŸ³é¢‘å¯¹è±¡ä»¥ä¾¿åç»­æ§åˆ¶
                    window.bgmAudio = {
                        audioContext: musicData.audioContext,
                        source: source,
                        gainNode: gainNode,
                        isPlaying: false,
                        paused: true,
                        volume: 0.3,
                        
                        play: function() {
                            return new Promise((resolve, reject) => {
                                try {
                                    if (this.audioContext.state === 'suspended') {
                                        this.audioContext.resume().then(() => {
                                            if (!this.isPlaying) {
                                                this.source.start();
                                                this.isPlaying = true;
                                                this.paused = false;
                                                debugLog('åˆæˆèƒŒæ™¯éŸ³ä¹å¼€å§‹æ’­æ”¾', 'success');
                                            }
                                            resolve();
                                        }).catch(reject);
                                    } else {
                                        if (!this.isPlaying) {
                                            this.source.start();
                                            this.isPlaying = true;
                                            this.paused = false;
                                            debugLog('åˆæˆèƒŒæ™¯éŸ³ä¹å¼€å§‹æ’­æ”¾', 'success');
                                        }
                                        resolve();
                                    }
                                } catch (error) {
                                    reject(error);
                                }
                            });
                        },
                        
                        pause: function() {
                            if (this.audioContext.state === 'running') {
                                this.audioContext.suspend();
                                this.paused = true;
                                debugLog('åˆæˆèƒŒæ™¯éŸ³ä¹å·²æš‚åœ', 'info');
                            }
                        },
                        
                        resume: function() {
                            if (this.audioContext.state === 'suspended') {
                                this.audioContext.resume();
                                this.paused = false;
                                debugLog('åˆæˆèƒŒæ™¯éŸ³ä¹å·²æ¢å¤', 'info');
                            }
                        }
                    };
                    
                    window.musicReady = true;
                    debugLog('åˆæˆèƒŒæ™¯éŸ³ä¹å¯¹è±¡åˆ›å»ºå®Œæˆ', 'success');
                }
            } catch (error) {
                debugLog('èƒŒæ™¯éŸ³ä¹å‡†å¤‡å¤±è´¥: ' + error.message, 'error');
                console.error('èƒŒæ™¯éŸ³ä¹å‡†å¤‡å¤±è´¥:', error);
            }
        }
        
        // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
        function playBackgroundMusic() {
            try {
                debugLog('å°è¯•æ’­æ”¾èƒŒæ™¯éŸ³ä¹...', 'info');
                
                if (!window.bgmAudio) {
                    debugLog('éŸ³é¢‘å¯¹è±¡ä¸å­˜åœ¨ï¼Œå‡†å¤‡åˆ›å»º...', 'warning');
                    prepareBackgroundMusic();
                    setTimeout(() => playBackgroundMusic(), 500);
                    return;
                }
                
                debugLog('éŸ³é¢‘å¯¹è±¡å­˜åœ¨ï¼Œæ£€æŸ¥çŠ¶æ€...', 'info');
                debugLog('éŸ³é¢‘å°±ç»ªçŠ¶æ€: ' + (window.musicReady ? 'æ˜¯' : 'å¦'), 'info');
                debugLog('éŸ³é¢‘ä¸Šä¸‹æ–‡çŠ¶æ€: ' + window.bgmAudio.audioContext.state, 'info');
                debugLog('éŸ³é¢‘æ’­æ”¾çŠ¶æ€: ' + (window.bgmAudio.paused ? 'æš‚åœ' : 'æ’­æ”¾'), 'info');
                
                if (window.musicReady && window.bgmAudio.paused) {
                    debugLog('å¼€å§‹æ’­æ”¾åˆæˆèƒŒæ™¯éŸ³ä¹...', 'info');
                    
                    const playPromise = window.bgmAudio.play();
                    
                    if (playPromise) {
                        playPromise.then(() => {
                            debugLog('èƒŒæ™¯éŸ³ä¹æ’­æ”¾æˆåŠŸï¼', 'success');
                            const toggleButton = document.getElementById('musicToggle');
                            if (toggleButton) {
                                toggleButton.textContent = 'ğŸµ æš‚åœéŸ³ä¹';
                            }
                        }).catch(error => {
                            debugLog('æ’­æ”¾å¤±è´¥: ' + error.name + ' - ' + error.message, 'error');
                            console.error('éŸ³é¢‘æ’­æ”¾é”™è¯¯:', error);
                            
                            // å¦‚æœæ˜¯ç”¨æˆ·äº¤äº’é—®é¢˜ï¼Œæç¤ºç”¨æˆ·
                            if (error.name === 'NotAllowedError') {
                                debugLog('æµè§ˆå™¨é˜»æ­¢äº†éŸ³é¢‘æ’­æ”¾ï¼Œè¯·æ‰‹åŠ¨ç‚¹å‡»æ’­æ”¾æŒ‰é’®', 'warning');
                            }
                        });
                    }
                } else if (!window.bgmAudio.paused) {
                    debugLog('èƒŒæ™¯éŸ³ä¹å·²åœ¨æ’­æ”¾ä¸­', 'info');
                } else {
                    debugLog('éŸ³é¢‘æœªå°±ç»ªï¼Œç­‰å¾…ä¸­...', 'warning');
                    setTimeout(() => playBackgroundMusic(), 500);
                }
                
            } catch (error) {
                debugLog('æ’­æ”¾éŸ³ä¹æ—¶å‘ç”Ÿå¼‚å¸¸: ' + error.message, 'error');
                console.error('æ’­æ”¾éŸ³ä¹å¼‚å¸¸:', error);
            }
        }
        
        // åœæ­¢èƒŒæ™¯éŸ³ä¹
        function stopBackgroundMusic() {
            try {
                if (window.bgmAudio) {
                    window.bgmAudio.pause();
                    // å¯¹äºåˆæˆéŸ³é¢‘ï¼Œæˆ‘ä»¬é‡ç½®æ’­æ”¾çŠ¶æ€
                    window.bgmAudio.isPlaying = false;
                    debugLog('èƒŒæ™¯éŸ³ä¹å·²åœæ­¢', 'info');
                    const toggleButton = document.getElementById('musicToggle');
                    if (toggleButton) {
                        toggleButton.textContent = 'ğŸµ æ’­æ”¾éŸ³ä¹';
                    }
                }
            } catch (error) {
                debugLog('åœæ­¢èƒŒæ™¯éŸ³ä¹å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // åˆ‡æ¢èƒŒæ™¯éŸ³ä¹æ’­æ”¾çŠ¶æ€
        function toggleBackgroundMusic() {
            try {
                debugLog('ç”¨æˆ·ç‚¹å‡»éŸ³ä¹åˆ‡æ¢æŒ‰é’®', 'info');
                const toggleButton = document.getElementById('musicToggle');
                
                if (window.bgmAudio) {
                    debugLog('éŸ³é¢‘å¯¹è±¡å­˜åœ¨ï¼Œå½“å‰çŠ¶æ€: ' + (window.bgmAudio.paused ? 'æš‚åœ' : 'æ’­æ”¾'), 'info');
                    
                    if (window.bgmAudio.paused) {
                        // å½“å‰æš‚åœï¼Œå¼€å§‹æ’­æ”¾æˆ–æ¢å¤
                        debugLog('å°è¯•æ’­æ”¾/æ¢å¤éŸ³ä¹...', 'info');
                        
                        if (window.bgmAudio.isPlaying) {
                            // å·²ç»åœ¨æ’­æ”¾ï¼Œåªæ˜¯è¢«æš‚åœäº†ï¼Œæ¢å¤æ’­æ”¾
                            window.bgmAudio.resume();
                            toggleButton.textContent = 'ğŸµ æš‚åœéŸ³ä¹';
                        } else {
                            // è¿˜æ²¡å¼€å§‹æ’­æ”¾ï¼Œå¼€å§‹æ’­æ”¾
                            const playPromise = window.bgmAudio.play();
                            
                            if (playPromise) {
                                playPromise.then(() => {
                                    debugLog('èƒŒæ™¯éŸ³ä¹æ’­æ”¾æˆåŠŸ', 'success');
                                    toggleButton.textContent = 'ğŸµ æš‚åœéŸ³ä¹';
                                }).catch(error => {
                                    debugLog('æ’­æ”¾å¤±è´¥: ' + error.name + ' - ' + error.message, 'error');
                                    console.error('æ’­æ”¾é”™è¯¯:', error);
                                });
                            }
                        }
                    } else {
                        // å½“å‰æ’­æ”¾ï¼Œæš‚åœ
                        debugLog('æš‚åœèƒŒæ™¯éŸ³ä¹', 'info');
                        window.bgmAudio.pause();
                        toggleButton.textContent = 'ğŸµ æ’­æ”¾éŸ³ä¹';
                    }
                } else {
                    // æ²¡æœ‰éŸ³é¢‘å¯¹è±¡ï¼Œé‡æ–°åˆ›å»ºå¹¶æ’­æ”¾
                    debugLog('éŸ³é¢‘å¯¹è±¡ä¸å­˜åœ¨ï¼Œåˆ›å»ºå¹¶æ’­æ”¾', 'warning');
                    playBackgroundMusic();
                }
            } catch (error) {
                debugLog('åˆ‡æ¢éŸ³ä¹çŠ¶æ€å¤±è´¥: ' + error.message, 'error');
                console.error('åˆ‡æ¢éŸ³ä¹çŠ¶æ€é”™è¯¯:', error);
            }
        }
        
        function debugLog(message, type = 'info') {
            const debugDiv = document.getElementById('debugInfo');
            if (debugDiv) {
                const line = document.createElement('div');
                line.className = `debug-line debug-${type}`;
                line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                debugDiv.appendChild(line);
                debugDiv.scrollTop = debugDiv.scrollHeight;
            }
            console.log(`[DEBUG-${type.toUpperCase()}] ${message}`);
        }
        
        function clearDebugLog() {
            const debugDiv = document.getElementById('debugInfo');
            if (debugDiv) {
                debugDiv.innerHTML = '<div class="debug-line debug-info">æ—¥å¿—å·²æ¸…ç©º...</div>';
            }
        }
        
        // åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ
        async function initTest() {
            try {
                canvas = document.getElementById('gameCanvas');
                ctx = canvas.getContext('2d');
                
                // ç¡®ä¿GameGlobalå­˜åœ¨
                if (!window.GameGlobal) {
                    debugLog('GameGlobalæœªæ‰¾åˆ°ï¼Œåˆ›å»ºåŸºæœ¬é…ç½®', 'warning');
                    window.GameGlobal = {
                        canvas: canvas,
                        ctx: ctx,
                        GameConfig: {
                            FISHING_SPEED: 200,
                            FISH_SCORES: { small: 10, medium: 20, large: 30 },
                            OBSTACLE_PENALTY: 10
                        },
                        GameState: {
                            reset: () => {},
                            isPaused: false,
                            isGameOver: false
                        },
                        Utils: {
                            getDistance: (x1, y1, x2, y2) => {
                                const dx = x2 - x1;
                                const dy = y2 - y1;
                                return Math.sqrt(dx * dx + dy * dy);
                            },
                            random: (min, max) => {
                                if (max === undefined) {
                                    max = min;
                                    min = 0;
                                }
                                return Math.random() * (max - min) + min;
                            },
                            clamp: (value, min, max) => {
                                return Math.min(Math.max(value, min), max);
                            }
                        }
                    };
                }
                
                // åˆ›å»ºåŠ¨ç”»ç®¡ç†å™¨
                animationManager = new window.AnimationManager();
                debugLog('åŠ¨ç”»ç®¡ç†å™¨åˆ›å»ºæˆåŠŸ', 'success');
                
                // åˆ›å»ºéŸ³é¢‘ç®¡ç†å™¨
                audioManager = new window.AudioManager();
                await audioManager.init();
                debugLog('éŸ³é¢‘ç®¡ç†å™¨åˆ›å»ºæˆåŠŸ', 'success');
                
                // å‡†å¤‡èƒŒæ™¯éŸ³ä¹ï¼ˆä½†ä¸ç«‹å³æ’­æ”¾ï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’ï¼‰
                prepareBackgroundMusic();
                debugLog('èƒŒæ™¯éŸ³ä¹å·²å‡†å¤‡å°±ç»ªï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’åæ’­æ”¾', 'info');
                
                // ç¡®ä¿GameGlobal.canvasæ­£ç¡®è®¾ç½®
                window.GameGlobal.canvas = canvas;
                window.GameGlobal.ctx = ctx;
                
                // åˆ›å»ºå°çŒ«å¯¹è±¡
                cat = new window.Cat(canvas.width / 2 - 30, 80);
                cat.init(); // æ‰‹åŠ¨è°ƒç”¨initæ–¹æ³•
                cat.setAnimationManager(animationManager);
                debugLog('å°çŒ«å¯¹è±¡åˆ›å»ºæˆåŠŸ', 'success');
                
                // åˆ›å»ºé±¼ç±»æ•°ç»„
                fishes = [];
                fishSpawnTimer = 0;
                
                // ç”Ÿæˆåˆå§‹é±¼ç±»
                spawnInitialFishes();
                
                // å¼€å§‹æ¸²æŸ“å¾ªç¯
                startRenderLoop();
                
                debugLog('æµ‹è¯•ç¯å¢ƒåˆå§‹åŒ–å®Œæˆ', 'success');
                
            } catch (error) {
                debugLog(`åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
                console.error('åˆå§‹åŒ–é”™è¯¯:', error);
            }
        }
        
        // æ³¢å…‰ç²¼ç²¼æ•ˆæœå˜é‡
        let waveTime = 0;
        let ripples = [];
        
        // æ·»åŠ æ°´æ³¢çº¹æ•ˆæœ
        function addRipple(x, y) {
            ripples.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: 50 + Math.random() * 30,
                alpha: 1,
                speed: 2 + Math.random()
            });
        }
        
        // å°†addRippleå‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
        window.addRipple = addRipple;
        
        // ç»˜åˆ¶çœŸå®é±¼å¡˜èƒŒæ™¯
        function drawPondBackground(currentTime) {
            // ç»˜åˆ¶æ°´é¢æ¸å˜èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');   // å¤©ç©ºè“
            gradient.addColorStop(0.3, '#4ECDC4'); // æµ…æ°´è“ç»¿
            gradient.addColorStop(0.6, '#2E8B57'); // æµ·ç»¿è‰²
            gradient.addColorStop(1, '#1C4E63');   // æ·±æ°´è“
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æ°´åº•è£…é¥°
            drawPondDecorations();
            
            // ç»˜åˆ¶æ³¢å…‰ç²¼ç²¼æ•ˆæœ
            drawWaterShimmer(currentTime);
            
            // ç»˜åˆ¶æ°´é¢æ³¢çº¹
            drawWaterRipples();
            
            // ç»˜åˆ¶æ°´é¢åå…‰
            drawWaterReflection();
        }
        
        // ç»˜åˆ¶é±¼å¡˜è£…é¥°å…ƒç´ 
        function drawPondDecorations() {
            // ç»˜åˆ¶æ°´åº•çŸ³å¤´
            drawPondRocks();
            
            // ç»˜åˆ¶æ°´è‰
            drawPondWeeds();
            
            // ç»˜åˆ¶æ°´åº•æ²™åœ°çº¹ç†
            drawPondBottom();
        }
        
        // ç»˜åˆ¶æ°´åº•çŸ³å¤´
        function drawPondRocks() {
            const rocks = [
                { x: 100, y: canvas.height - 80, width: 40, height: 25 },
                { x: 300, y: canvas.height - 60, width: 30, height: 20 },
                { x: 500, y: canvas.height - 90, width: 50, height: 30 },
                { x: 650, y: canvas.height - 70, width: 35, height: 22 }
            ];
            
            rocks.forEach(rock => {
                ctx.save();
                ctx.globalAlpha = 0.7;
                
                // çŸ³å¤´ä¸»ä½“
                const gradient = ctx.createRadialGradient(
                    rock.x + rock.width * 0.3, rock.y + rock.height * 0.3, 0,
                    rock.x + rock.width * 0.5, rock.y + rock.height * 0.5, rock.width
                );
                gradient.addColorStop(0, '#8B7D6B');
                gradient.addColorStop(1, '#5D4E37');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(rock.x + rock.width/2, rock.y + rock.height/2, 
                           rock.width/2, rock.height/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // çŸ³å¤´é«˜å…‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.ellipse(rock.x + rock.width * 0.3, rock.y + rock.height * 0.3, 
                           rock.width * 0.2, rock.height * 0.15, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }
        
        // ç»˜åˆ¶æ°´è‰
        function drawPondWeeds() {
            const weeds = [
                { x: 50, y: canvas.height - 120, height: 80, sway: 0 },
                { x: 200, y: canvas.height - 100, height: 60, sway: 1 },
                { x: 400, y: canvas.height - 130, height: 90, sway: 0.5 },
                { x: 600, y: canvas.height - 110, height: 70, sway: 1.5 },
                { x: 750, y: canvas.height - 95, height: 55, sway: 0.8 }
            ];
            
            weeds.forEach(weed => {
                ctx.save();
                ctx.globalAlpha = 0.6;
                
                const swayOffset = Math.sin(waveTime * 2 + weed.sway) * 8;
                
                // ç»˜åˆ¶å¤šç‰‡æ°´è‰å¶å­
                for (let i = 0; i < 3; i++) {
                    const leafX = weed.x + i * 8 - 8;
                    const leafWidth = 6;
                    const segments = 8;
                    
                    ctx.strokeStyle = i === 1 ? '#228B22' : '#32CD32';
                    ctx.lineWidth = leafWidth - i;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(leafX, weed.y);
                    
                    for (let j = 1; j <= segments; j++) {
                        const t = j / segments;
                        const y = weed.y - weed.height * t;
                        const x = leafX + Math.sin(t * Math.PI + waveTime + weed.sway) * swayOffset * t;
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }
        
        // ç»˜åˆ¶æ°´åº•æ²™åœ°
        function drawPondBottom() {
            ctx.save();
            ctx.globalAlpha = 0.4;
            
            // æ²™åœ°æ¸å˜
            const sandGradient = ctx.createLinearGradient(0, canvas.height - 50, 0, canvas.height);
            sandGradient.addColorStop(0, 'rgba(194, 178, 128, 0)');
            sandGradient.addColorStop(1, 'rgba(160, 144, 94, 0.8)');
            
            ctx.fillStyle = sandGradient;
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
            
            // æ²™åœ°çº¹ç†ç‚¹
            ctx.fillStyle = 'rgba(139, 125, 107, 0.3)';
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * canvas.width;
                const y = canvas.height - 50 + Math.random() * 50;
                const size = Math.random() * 2 + 1;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶æ³¢å…‰ç²¼ç²¼æ•ˆæœ
        function drawWaterShimmer(currentTime) {
            waveTime = currentTime * 0.001;
            
            // åˆ›å»ºå¤šå±‚æ³¢å…‰æ•ˆæœ
            for (let layer = 0; layer < 3; layer++) {
                ctx.save();
                ctx.globalAlpha = 0.1 + layer * 0.05;
                
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                
                // ç»˜åˆ¶æ³¢æµªå½¢çŠ¶çš„å…‰æ–‘
                ctx.beginPath();
                for (let x = 0; x <= canvas.width; x += 10) {
                    const y1 = canvas.height * 0.3 + Math.sin(x * 0.01 + waveTime * (2 + layer)) * (15 + layer * 5);
                    const y2 = y1 + 20 + layer * 10;
                    
                    if (x === 0) {
                        ctx.moveTo(x, y1);
                    } else {
                        ctx.lineTo(x, y1);
                    }
                }
                
                for (let x = canvas.width; x >= 0; x -= 10) {
                    const y2 = canvas.height * 0.3 + Math.sin(x * 0.01 + waveTime * (2 + layer)) * (15 + layer * 5) + 20 + layer * 10;
                    ctx.lineTo(x, y2);
                }
                
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }
        
        // ç»˜åˆ¶æ°´é¢æ³¢çº¹
        function drawWaterRipples() {
            // æ›´æ–°æ³¢çº¹
            ripples = ripples.filter(ripple => {
                ripple.radius += ripple.speed;
                ripple.alpha = Math.max(0, 1 - (ripple.radius / ripple.maxRadius));
                return ripple.alpha > 0;
            });
            
            // ç»˜åˆ¶æ³¢çº¹
            ripples.forEach(ripple => {
                ctx.save();
                ctx.globalAlpha = ripple.alpha * 0.6;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });
            
            // éšæœºæ·»åŠ æ–°æ³¢çº¹
            if (Math.random() < 0.02) {
                addRipple(
                    Math.random() * canvas.width,
                    canvas.height * 0.4 + Math.random() * canvas.height * 0.5
                );
            }
        }
        
        // ç»˜åˆ¶æ°´é¢åå…‰
        function drawWaterReflection() {
            // ç»˜åˆ¶åŠ¨æ€çš„æ°´é¢åå…‰çº¿
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 5; i++) {
                ctx.setLineDash([5 + i * 2, 10 + i * 3]);
                ctx.beginPath();
                
                const baseY = canvas.height * 0.4 + i * 30;
                for (let x = 0; x <= canvas.width; x += 20) {
                    const y = baseY + Math.sin(x * 0.02 + waveTime * (1 + i * 0.5)) * (3 + i);
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            ctx.restore();
        }
        
        function startRenderLoop() {
            let lastTime = 0;
            
            function render(currentTime) {
                const deltaTime = (currentTime - lastTime) / 1000;
                lastTime = currentTime;
                
                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶çœŸå®é±¼å¡˜èƒŒæ™¯
                drawPondBackground(currentTime);
                
                // æ›´æ–°æ¸¸æˆæ—¶é—´
                updateGameTimer(deltaTime);
                
                // æ›´æ–°é±¼ç±»ç”Ÿæˆ
                updateFishSpawning(deltaTime);
                
                // æ›´æ–°å’Œæ¸²æŸ“é±¼ç±»
                updateAndRenderFishes(deltaTime);
                
                // æ›´æ–°å’Œæ¸²æŸ“å°çŒ«
                if (cat) {
                    cat.update(deltaTime);
                    cat.render(ctx);
                }
                
                // æ£€æŸ¥ç¢°æ’
                checkFishingCollisions();
                
                // æ›´æ–°åŠ¨ç”»ç®¡ç†å™¨
                if (animationManager) {
                    animationManager.update(deltaTime);
                }
                
                // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
                renderDebugInfo();
                
                requestAnimationFrame(render);
            }
            
            requestAnimationFrame(render);
        }
        
        // ç”Ÿæˆåˆå§‹é±¼ç±»
        function spawnInitialFishes() {
            for (let i = 0; i < 10; i++) {
                spawnFish();
            }
            debugLog('ç”Ÿæˆäº†10æ¡åˆå§‹é±¼ç±»', 'success');
        }
        
        // ç”Ÿæˆå•æ¡é±¼
        function spawnFish() {
            const fishTypes = ['shark', 'loach', 'grass_carp', 'whale', 'crucian_carp', 'bighead_carp', 'goldfish'];
            const fishType = fishTypes[Math.floor(Math.random() * fishTypes.length)];
            
            const fish = {
                type: fishType,
                x: Math.random() * (canvas.width - 60),
                y: canvas.height * 0.4 + Math.random() * (canvas.height * 0.55),
                width: getFishSize(fishType).width,
                height: getFishSize(fishType).height,
                speed: 30 + Math.random() * 50,
                direction: Math.random() > 0.5 ? 1 : -1,
                color: getFishColor(fishType),
                secondaryColor: getSecondaryColor(fishType),
                pattern: getFishPattern(fishType),
                animationTime: 0,
                isActive: true,
                glowEffect: fishType === 'rare',
                glowIntensity: 0,
                tailType: getTailType(fishType),
                finType: getFinType(fishType)
            };
            
            fishes.push(fish);
        }
        
        // è·å–é±¼ç±»å¤§å°
        function getFishSize(type) {
            const sizes = {
                shark: { width: 70, height: 35 },
                loach: { width: 25, height: 15 },
                grass_carp: { width: 50, height: 30 },
                whale: { width: 90, height: 50 },
                crucian_carp: { width: 35, height: 25 },
                bighead_carp: { width: 55, height: 40 },
                goldfish: { width: 30, height: 25 }
            };
            return sizes[type] || sizes.goldfish;
        }
        
        // è·å–é±¼ç±»ä¸»é¢œè‰²
        function getFishColor(type) {
            const colors = {
                shark: '#708090',
                loach: '#8B4513',
                grass_carp: '#228B22',
                whale: '#2F4F4F',
                crucian_carp: '#D2691E',
                bighead_carp: '#696969',
                goldfish: '#FFD700'
            };
            return colors[type] || colors.goldfish;
        }
        
        // è·å–é±¼ç±»æ¬¡è¦é¢œè‰²
        function getSecondaryColor(type) {
            const colors = {
                shark: '#2F4F4F',
                loach: '#654321',
                grass_carp: '#006400',
                whale: '#191970',
                crucian_carp: '#B8860B',
                bighead_carp: '#2F2F2F',
                goldfish: '#FFA500'
            };
            return colors[type] || colors.goldfish;
        }
        
        // è·å–é±¼ç±»å›¾æ¡ˆ
        function getFishPattern(type) {
            const patterns = {
                shark: 'smooth',
                loach: 'solid',
                grass_carp: 'scales',
                whale: 'gradient',
                crucian_carp: 'solid',
                bighead_carp: 'gradient',
                goldfish: 'sparkle'
            };
            return patterns[type] || 'solid';
        }
        
        // è·å–å°¾å·´ç±»å‹
        function getTailType(type) {
            const tailTypes = {
                shark: 'crescent',
                loach: 'rounded',
                grass_carp: 'forked',
                whale: 'broad',
                crucian_carp: 'rounded',
                bighead_carp: 'broad',
                goldfish: 'flowing'
            };
            return tailTypes[type] || 'standard';
        }
        
        // è·å–é±¼é³ç±»å‹
        function getFinType(type) {
            const finTypes = {
                shark: 'sharp',
                loach: 'small',
                grass_carp: 'standard',
                whale: 'large',
                crucian_carp: 'rounded',
                bighead_carp: 'large',
                goldfish: 'flowing'
            };
            return finTypes[type] || 'standard';
        }
        
        // æ›´æ–°é±¼ç±»ç”Ÿæˆï¼ˆç¡®ä¿æ± å¡˜ä¸­å§‹ç»ˆä¿æŒ10æ¡é±¼ï¼‰
        function updateFishSpawning(deltaTime) {
            // æ£€æŸ¥å½“å‰æ´»è·ƒé±¼ç±»æ•°é‡ï¼Œå¦‚æœå°‘äº10æ¡åˆ™è¡¥å……
            const activeFishCount = fishes.filter(fish => !fish.isCaught).length;
            if (activeFishCount < 10) {
                const needToSpawn = 10 - activeFishCount;
                for (let i = 0; i < needToSpawn; i++) {
                    spawnFish();
                }
                debugLog(`æ± å¡˜é±¼æ•°ä¸è¶³ï¼Œå·²è¡¥å……${needToSpawn}æ¡é±¼ï¼Œå½“å‰æ± å¡˜é±¼æ•°: ${fishes.length}`, 'info');
            }
        }
        
        // æ›´æ–°å’Œæ¸²æŸ“é±¼ç±»
        function updateAndRenderFishes(deltaTime) {
            for (let i = fishes.length - 1; i >= 0; i--) {
                const fish = fishes[i];
                
                // å¦‚æœé±¼è¢«æ•è·ï¼Œè·³è¿‡ä½ç½®æ›´æ–°
                if (!fish.isCaught) {
                    // æ›´æ–°é±¼ç±»ä½ç½®
                    fish.x += fish.speed * fish.direction * deltaTime;
                    fish.animationTime += deltaTime;
                }
                
                // æ£€æŸ¥è¾¹ç•Œï¼Œç§»é™¤è¶…å‡ºå±å¹•çš„é±¼ï¼ˆä½†ä¸ç§»é™¤è¢«æ•è·çš„é±¼ï¼‰
                if (!fish.isCaught && (fish.x < -fish.width || fish.x > canvas.width + fish.width)) {
                    fishes.splice(i, 1);
                    // ç«‹å³ç”Ÿæˆä¸€æ¡æ–°é±¼ä»¥ä¿æŒæ± å¡˜æ•°é‡æ’å®š
                    spawnFish();
                    debugLog(`é±¼æ¸¸å‡ºè¾¹ç•Œï¼Œå·²è¡¥å……æ–°é±¼ï¼Œæ± å¡˜é±¼æ•°: ${fishes.length}`, 'info');
                    continue;
                }
                
                // åªæ¸²æŸ“æœªè¢«æ•è·çš„é±¼ï¼Œè¢«æ•è·çš„é±¼ç”±Catå¯¹è±¡æ¸²æŸ“
                if (!fish.isCaught) {
                    renderFish(fish);
                }
            }
        }
        
        // æ¸²æŸ“å•æ¡é±¼
        function renderFish(fish) {
            ctx.save();
            
            // æ›´æ–°å‘å…‰æ•ˆæœ
            if (fish.glowEffect) {
                fish.glowIntensity = 0.5 + Math.sin(fish.animationTime * 3) * 0.3;
            }
            
            // ç§»åŠ¨åˆ°é±¼çš„ä½ç½®
            ctx.translate(fish.x + fish.width / 2, fish.y + fish.height / 2);
            
            // å¦‚æœå‘å·¦æ¸¸ï¼Œç¿»è½¬é±¼
            if (fish.direction < 0) {
                ctx.scale(-1, 1);
            }
            
            // æ·»åŠ æ¸¸æ³³åŠ¨ç”»
            const swimOffset = Math.sin(fish.animationTime * 3) * 2;
            const tailWave = Math.sin(fish.animationTime * 4) * 5;
            
            // ç»˜åˆ¶å‘å…‰æ•ˆæœï¼ˆç¨€æœ‰é±¼ï¼‰
            if (fish.glowEffect) {
                drawFishGlow(fish);
            }
            
            // ç»˜åˆ¶é±¼èº«
            drawFishBody(fish, swimOffset);
            
            // ç»˜åˆ¶é±¼å°¾
            drawFishTail(fish, tailWave);
            
            // ç»˜åˆ¶é±¼é³
            drawFishFins(fish, swimOffset);
            
            // ç»˜åˆ¶é±¼çœ¼
            drawFishEyes(fish);
            
            // ç»˜åˆ¶å›¾æ¡ˆ
            drawFishPattern(fish);
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶é±¼ç±»å‘å…‰æ•ˆæœ
        function drawFishGlow(fish) {
            ctx.save();
            ctx.globalAlpha = fish.glowIntensity * 0.6;
            
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, fish.width);
            gradient.addColorStop(0, fish.color);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, fish.width * 0.8, fish.height * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶é±¼èº«ï¼ˆæ ¹æ®ç±»å‹é€‰æ‹©ç»˜åˆ¶æ–¹å¼ï¼‰
        function drawFishBody(fish, swimOffset) {
            ctx.save();
            
            // æ ¹æ®é±¼ç±»ç±»å‹ä½¿ç”¨ç‰¹æ®Šç»˜åˆ¶
            if (fish.type === 'shark') {
                // é²¨é±¼æµçº¿å‹é±¼èº«
                const bodyGradient = ctx.createLinearGradient(-fish.width/2, swimOffset - fish.height/2, fish.width/2, swimOffset + fish.height/2);
                bodyGradient.addColorStop(0, fish.color);
                bodyGradient.addColorStop(0.3, fish.secondaryColor);
                bodyGradient.addColorStop(1, darkenColor(fish.color, 0.2));
                ctx.fillStyle = bodyGradient;
                
                // ç»˜åˆ¶æµçº¿å‹é²¨é±¼èº«ä½“
                ctx.beginPath();
                ctx.moveTo(-fish.width/2, swimOffset);
                ctx.quadraticCurveTo(-fish.width/3, swimOffset - fish.height/2, fish.width/4, swimOffset - fish.height/3);
                ctx.quadraticCurveTo(fish.width/2, swimOffset, fish.width/4, swimOffset + fish.height/3);
                ctx.quadraticCurveTo(-fish.width/3, swimOffset + fish.height/2, -fish.width/2, swimOffset);
                ctx.fill();
                
                // ç§»é™¤è½®å»“çº¿æ¡
            } else if (fish.type === 'loach') {
                // æ³¥é³…ç»†é•¿èº«ä½“
                ctx.fillStyle = fish.color;
                ctx.beginPath();
                ctx.ellipse(0, swimOffset, fish.width / 2, fish.height / 3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // æ·»åŠ æ³¥é³…ç‰¹æœ‰çš„æ¡çº¹
                ctx.strokeStyle = darkenColor(fish.color, 0.3);
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-fish.width/3 + i * fish.width/6, swimOffset - fish.height/4);
                    ctx.lineTo(-fish.width/3 + i * fish.width/6, swimOffset + fish.height/4);
                    ctx.stroke();
                }
            } else if (fish.type === 'whale') {
                // é²¸é±¼å·¨å¤§èº«ä½“
                const whaleGradient = ctx.createLinearGradient(0, swimOffset - fish.height/2, 0, swimOffset + fish.height/2);
                whaleGradient.addColorStop(0, fish.color);
                whaleGradient.addColorStop(0.5, lightenColor(fish.color, 0.2));
                whaleGradient.addColorStop(1, darkenColor(fish.color, 0.2));
                ctx.fillStyle = whaleGradient;
                
                ctx.beginPath();
                ctx.ellipse(0, swimOffset, fish.width / 2, fish.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // é²¸é±¼è…¹éƒ¨ç™½è‰²
                ctx.fillStyle = '#F0F8FF';
                ctx.beginPath();
                ctx.ellipse(0, swimOffset + fish.height/4, fish.width / 3, fish.height / 4, 0, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // åŸæ¥çš„é±¼èº«ç»˜åˆ¶æ–¹å¼
                ctx.fillStyle = fish.color;
                ctx.beginPath();
                ctx.ellipse(0, swimOffset, fish.width / 2, fish.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // æ·»åŠ æ¸å˜æ•ˆæœ
                const gradient = ctx.createRadialGradient(0, swimOffset - fish.height/4, 0, 0, swimOffset, fish.width/2);
                gradient.addColorStop(0, lightenColor(fish.color, 0.3));
                gradient.addColorStop(1, fish.color);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // ç®€åŒ–çš„é±¼èº«å…‰æ³½æ•ˆæœ
        function drawBodyShine(fish, swimOffset) {
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(-fish.width/6, swimOffset - fish.height/6, fish.width/8, fish.height/8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // é¢œè‰²è¾…åŠ©å‡½æ•°
        function lightenColor(color, amount) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(255 * amount);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }
        
        function darkenColor(color, amount) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(255 * amount);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            return '#' + (0x1000000 + (R > 0 ? R : 0) * 0x10000 +
                (G > 0 ? G : 0) * 0x100 + (B > 0 ? B : 0)).toString(16).slice(1);
        }
        
        // ç»˜åˆ¶çœŸå®é±¼å°¾
        function drawFishTail(fish, tailWave) {
            ctx.save();
            
            if (fish.type === 'shark') {
                // é²¨é±¼æœˆç‰™å½¢å°¾å·´
                ctx.fillStyle = fish.color;
                const tailX = -fish.width / 2;
                const tailSize = fish.width * 0.5;
                
                ctx.beginPath();
                // ä¸ŠåŠéƒ¨åˆ†
                ctx.moveTo(tailX, tailWave);
                ctx.quadraticCurveTo(tailX - tailSize * 0.8, tailWave - tailSize * 0.6, tailX - tailSize, tailWave - tailSize * 0.3);
                ctx.quadraticCurveTo(tailX - tailSize * 0.6, tailWave - tailSize * 0.1, tailX - tailSize * 0.3, tailWave);
                // ä¸‹åŠéƒ¨åˆ†
                ctx.quadraticCurveTo(tailX - tailSize * 0.6, tailWave + tailSize * 0.1, tailX - tailSize, tailWave + tailSize * 0.3);
                ctx.quadraticCurveTo(tailX - tailSize * 0.8, tailWave + tailSize * 0.6, tailX, tailWave);
                ctx.fill();
                
                // ç§»é™¤è½®å»“çº¿æ¡
            } else {
                // åŸæ¥çš„é±¼å°¾ç»˜åˆ¶æ–¹å¼
                ctx.fillStyle = fish.color;
                const tailX = -fish.width / 2;
                const tailSize = fish.width * 0.3;
                
                ctx.beginPath();
                ctx.moveTo(tailX, tailWave);
                ctx.quadraticCurveTo(tailX - tailSize, tailWave - tailSize/2, tailX - tailSize * 0.8, tailWave);
                ctx.quadraticCurveTo(tailX - tailSize, tailWave + tailSize/2, tailX, tailWave);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // å„ç§é±¼å°¾å½¢çŠ¶çš„ç»˜åˆ¶å‡½æ•°
        function drawForkedTail(tailX, tailWave, tailSize, fishHeight) {
            ctx.moveTo(tailX, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.6, tailWave - fishHeight * 0.4, tailX - tailSize, tailWave - fishHeight * 0.3);
            ctx.quadraticCurveTo(tailX - tailSize * 0.8, tailWave - fishHeight * 0.1, tailX - tailSize * 0.6, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.8, tailWave + fishHeight * 0.1, tailX - tailSize, tailWave + fishHeight * 0.3);
            ctx.quadraticCurveTo(tailX - tailSize * 0.6, tailWave + fishHeight * 0.4, tailX, tailWave);
        }
        
        function drawBroadTail(tailX, tailWave, tailSize, fishHeight) {
            ctx.moveTo(tailX, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.7, tailWave - fishHeight * 0.5, tailX - tailSize * 0.9, tailWave - fishHeight * 0.4);
            ctx.quadraticCurveTo(tailX - tailSize, tailWave, tailX - tailSize * 0.9, tailWave + fishHeight * 0.4);
            ctx.quadraticCurveTo(tailX - tailSize * 0.7, tailWave + fishHeight * 0.5, tailX, tailWave);
        }
        
        function drawFlowingTail(tailX, tailWave, tailSize, fishHeight) {
            ctx.moveTo(tailX, tailWave);
            ctx.bezierCurveTo(
                tailX - tailSize * 0.3, tailWave - fishHeight * 0.3,
                tailX - tailSize * 0.8, tailWave - fishHeight * 0.2,
                tailX - tailSize * 1.1, tailWave
            );
            ctx.bezierCurveTo(
                tailX - tailSize * 0.8, tailWave + fishHeight * 0.2,
                tailX - tailSize * 0.3, tailWave + fishHeight * 0.3,
                tailX, tailWave
            );
        }
        
        function drawTriangularTail(tailX, tailWave, tailSize, fishHeight) {
            ctx.moveTo(tailX, tailWave);
            ctx.lineTo(tailX - tailSize * 1.2, tailWave - fishHeight * 0.2);
            ctx.quadraticCurveTo(tailX - tailSize * 1.3, tailWave, tailX - tailSize * 1.2, tailWave + fishHeight * 0.2);
            ctx.lineTo(tailX, tailWave);
        }
        
        function drawRoundedTail(tailX, tailWave, tailSize, fishHeight) {
            ctx.moveTo(tailX, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.5, tailWave - fishHeight * 0.3, tailX - tailSize * 0.8, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.5, tailWave + fishHeight * 0.3, tailX, tailWave);
        }
        
        function drawStandardTail(tailX, tailWave, tailSize, fishHeight) {
            ctx.moveTo(tailX, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.6, tailWave - fishHeight * 0.35, tailX - tailSize * 0.9, tailWave);
            ctx.quadraticCurveTo(tailX - tailSize * 0.6, tailWave + fishHeight * 0.35, tailX, tailWave);
        }
        
        // ç»˜åˆ¶é±¼å°¾çº¹ç†
        function drawTailTexture(fish, tailX, tailWave, tailSize) {
            ctx.save();
            ctx.strokeStyle = darkenColor(fish.secondaryColor, 0.4);
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.6;
            
            // ç»˜åˆ¶é±¼å°¾çš„æ”¾å°„çŠ¶çº¹ç†
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(tailX - tailSize * 0.2, tailWave);
                ctx.lineTo(tailX - tailSize * 0.8, tailWave + (i - 1) * fish.height * 0.15);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶çœŸå®é±¼é³
        function drawFishFins(fish, swimOffset) {
            ctx.save();
            
            const finOffset = Math.sin(fish.animationTime * 2.5) * 2;
            
            if (fish.type === 'shark') {
                // é²¨é±¼å°–é”é±¼é³
                ctx.fillStyle = fish.secondaryColor;
                const finSize = fish.width * 0.2;
                
                // èƒŒé³ - ä¸‰è§’å½¢
                ctx.beginPath();
                ctx.moveTo(-fish.width * 0.1, swimOffset - fish.height * 0.3 + finOffset);
                ctx.lineTo(0, swimOffset - fish.height * 0.6 + finOffset);
                ctx.lineTo(fish.width * 0.1, swimOffset - fish.height * 0.3 + finOffset);
                ctx.closePath();
                ctx.fill();
                
                // è…¹é³ - å°ä¸‰è§’å½¢
                ctx.beginPath();
                ctx.moveTo(-fish.width * 0.05, swimOffset + fish.height * 0.25 - finOffset);
                ctx.lineTo(0, swimOffset + fish.height * 0.4 - finOffset);
                ctx.lineTo(fish.width * 0.05, swimOffset + fish.height * 0.25 - finOffset);
                ctx.closePath();
                ctx.fill();
                
                // èƒ¸é³ - å°–é”å½¢çŠ¶
                ctx.beginPath();
                ctx.moveTo(fish.width * 0.05, swimOffset + finOffset * 0.5);
                ctx.lineTo(fish.width * 0.2, swimOffset - fish.height * 0.1 + finOffset * 0.5);
                ctx.lineTo(fish.width * 0.15, swimOffset + fish.height * 0.1 + finOffset * 0.5);
                ctx.closePath();
                ctx.fill();
            } else if (fish.type === 'loach') {
                // æ³¥é³…å°é±¼é³
                ctx.fillStyle = fish.secondaryColor;
                const finSize = fish.width * 0.1;
                
                // å°èƒŒé³
                ctx.beginPath();
                ctx.arc(0, swimOffset - fish.height * 0.2 + finOffset, finSize * 0.5, 0, Math.PI, true);
                ctx.fill();
                
                // å°è…¹é³
                ctx.beginPath();
                ctx.arc(0, swimOffset + fish.height * 0.15 - finOffset, finSize * 0.3, Math.PI, 0, true);
                ctx.fill();
            } else if (fish.type === 'whale') {
                // é²¸é±¼å¤§é±¼é³
                ctx.fillStyle = fish.secondaryColor;
                const finSize = fish.width * 0.3;
                
                // å¤§èƒŒé³
                ctx.beginPath();
                ctx.moveTo(-fish.width * 0.2, swimOffset - fish.height * 0.4 + finOffset);
                ctx.quadraticCurveTo(0, swimOffset - fish.height * 0.6 + finOffset, fish.width * 0.2, swimOffset - fish.height * 0.4 + finOffset);
                ctx.quadraticCurveTo(0, swimOffset - fish.height * 0.3, -fish.width * 0.2, swimOffset - fish.height * 0.4 + finOffset);
                ctx.fill();
                
                // å¤§èƒ¸é³
                ctx.beginPath();
                ctx.ellipse(fish.width * 0.1, swimOffset + finOffset * 0.5, finSize * 0.8, finSize * 0.4, -Math.PI / 6, 0, 2 * Math.PI);
                ctx.fill();
            } else {
                // æ ¹æ®é±¼é³ç±»å‹ç»˜åˆ¶
                ctx.fillStyle = fish.secondaryColor;
                const finSize = fish.width * 0.2;
                
                switch (fish.finType) {
                    case 'sharp':
                        drawSharpFins(fish, finSize, swimOffset, finOffset);
                        break;
                    case 'small':
                        drawSmallFins(fish, finSize, swimOffset, finOffset);
                        break;
                    case 'large':
                        drawLargeFins(fish, finSize, swimOffset, finOffset);
                        break;
                    case 'rounded':
                        drawRoundedFins(fish, finSize, swimOffset, finOffset);
                        break;
                    case 'flowing':
                        drawFlowingFins(fish, finSize, swimOffset, finOffset);
                        break;
                    case 'standard':
                    default:
                        drawStandardFins(fish, finSize, swimOffset, finOffset);
                        break;
                }
            }
            
            ctx.restore();
        }
        
        // å„ç§é±¼é³å½¢çŠ¶çš„ç»˜åˆ¶å‡½æ•°
        function drawLargeFins(fish, finSize, swimOffset, finOffset) {
            // èƒŒé³
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.2, -fish.height * 0.4 + swimOffset + finOffset);
            ctx.quadraticCurveTo(0, -fish.height * 0.6 + swimOffset + finOffset, fish.width * 0.2, -fish.height * 0.4 + swimOffset + finOffset);
            ctx.quadraticCurveTo(0, -fish.height * 0.3 + swimOffset, -fish.width * 0.2, -fish.height * 0.4 + swimOffset + finOffset);
            ctx.fill();
            
            // è…¹é³
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.1, fish.height * 0.3 + swimOffset - finOffset);
            ctx.quadraticCurveTo(0, fish.height * 0.5 + swimOffset - finOffset, fish.width * 0.1, fish.height * 0.3 + swimOffset - finOffset);
            ctx.quadraticCurveTo(0, fish.height * 0.25 + swimOffset, -fish.width * 0.1, fish.height * 0.3 + swimOffset - finOffset);
            ctx.fill();
        }
        
        function drawFlowingFins(fish, finSize, swimOffset, finOffset) {
            // èƒŒé³
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.3, -fish.height * 0.3 + swimOffset + finOffset);
            ctx.bezierCurveTo(
                -fish.width * 0.1, -fish.height * 0.7 + swimOffset + finOffset,
                fish.width * 0.1, -fish.height * 0.7 + swimOffset + finOffset,
                fish.width * 0.3, -fish.height * 0.3 + swimOffset + finOffset
            );
            ctx.quadraticCurveTo(0, -fish.height * 0.25 + swimOffset, -fish.width * 0.3, -fish.height * 0.3 + swimOffset + finOffset);
            ctx.fill();
            
            // è…¹é³
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.2, fish.height * 0.25 + swimOffset - finOffset);
            ctx.quadraticCurveTo(0, fish.height * 0.45 + swimOffset - finOffset, fish.width * 0.2, fish.height * 0.25 + swimOffset - finOffset);
            ctx.quadraticCurveTo(0, fish.height * 0.2 + swimOffset, -fish.width * 0.2, fish.height * 0.25 + swimOffset - finOffset);
            ctx.fill();
        }
        
        function drawPointedFins(fish, finSize, swimOffset, finOffset) {
            // èƒŒé³ï¼ˆå¤©ä½¿é±¼ç‰¹æœ‰çš„é«˜èƒŒé³ï¼‰
            ctx.beginPath();
            ctx.moveTo(0, -fish.height * 0.3 + swimOffset + finOffset);
            ctx.lineTo(-fish.width * 0.1, -fish.height * 0.8 + swimOffset + finOffset);
            ctx.lineTo(fish.width * 0.1, -fish.height * 0.8 + swimOffset + finOffset);
            ctx.closePath();
            ctx.fill();
            
            // è…¹é³ï¼ˆå¤©ä½¿é±¼ç‰¹æœ‰çš„é•¿è…¹é³ï¼‰
            ctx.beginPath();
            ctx.moveTo(0, fish.height * 0.3 + swimOffset - finOffset);
            ctx.lineTo(-fish.width * 0.05, fish.height * 0.7 + swimOffset - finOffset);
            ctx.lineTo(fish.width * 0.05, fish.height * 0.7 + swimOffset - finOffset);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawRoundedFins(fish, finSize, swimOffset, finOffset) {
            // èƒŒé³
            ctx.beginPath();
            ctx.arc(0, -fish.height * 0.35 + swimOffset + finOffset, finSize * 0.8, 0, Math.PI, true);
            ctx.fill();
            
            // è…¹é³
            ctx.beginPath();
            ctx.arc(0, fish.height * 0.3 + swimOffset - finOffset, finSize * 0.6, Math.PI, 0, true);
            ctx.fill();
        }
        
        function drawDelicateFins(fish, finSize, swimOffset, finOffset) {
            // å¤šæ®µå¼èƒŒé³
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                const x = (i - 1) * fish.width * 0.15;
                ctx.ellipse(x, -fish.height * 0.35 + swimOffset + finOffset, finSize * 0.4, finSize * 0.6, 0, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // è…¹é³
            ctx.beginPath();
            ctx.ellipse(0, fish.height * 0.3 + swimOffset - finOffset, finSize * 0.7, finSize * 0.4, 0, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        function drawStandardFins(fish, finSize, swimOffset, finOffset) {
            // èƒŒé³
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.15, -fish.height * 0.3 + swimOffset + finOffset);
            ctx.quadraticCurveTo(0, -fish.height * 0.5 + swimOffset + finOffset, fish.width * 0.15, -fish.height * 0.3 + swimOffset + finOffset);
            ctx.quadraticCurveTo(0, -fish.height * 0.25 + swimOffset, -fish.width * 0.15, -fish.height * 0.3 + swimOffset + finOffset);
            ctx.fill();
            
            // è…¹é³
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.1, fish.height * 0.25 + swimOffset - finOffset);
            ctx.quadraticCurveTo(0, fish.height * 0.4 + swimOffset - finOffset, fish.width * 0.1, fish.height * 0.25 + swimOffset - finOffset);
            ctx.quadraticCurveTo(0, fish.height * 0.2 + swimOffset, -fish.width * 0.1, fish.height * 0.25 + swimOffset - finOffset);
            ctx.fill();
        }
        
        function drawSmallFins(fish, finSize, swimOffset, finOffset) {
            // å°èƒŒé³
            ctx.beginPath();
            ctx.arc(0, -fish.height * 0.25 + swimOffset + finOffset, finSize * 0.4, 0, Math.PI, true);
            ctx.fill();
            
            // å°è…¹é³
            ctx.beginPath();
            ctx.arc(0, fish.height * 0.2 + swimOffset - finOffset, finSize * 0.3, Math.PI, 0, true);
            ctx.fill();
        }
        
        function drawSharpFins(fish, finSize, swimOffset, finOffset) {
            // å°–é”èƒŒé³
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.1, swimOffset - fish.height * 0.3 + finOffset);
            ctx.lineTo(0, swimOffset - fish.height * 0.6 + finOffset);
            ctx.lineTo(fish.width * 0.1, swimOffset - fish.height * 0.3 + finOffset);
            ctx.closePath();
            ctx.fill();
            
            // å°–é”è…¹é³
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.05, swimOffset + fish.height * 0.25 - finOffset);
            ctx.lineTo(0, swimOffset + fish.height * 0.4 - finOffset);
            ctx.lineTo(fish.width * 0.05, swimOffset + fish.height * 0.25 - finOffset);
            ctx.closePath();
            ctx.fill();
        }
        
        // ç»˜åˆ¶èƒ¸é³
        function drawPectoralFins(fish, finSize, swimOffset, finOffset) {
            ctx.save();
            ctx.globalAlpha = 0.8;
            
            // å·¦èƒ¸é³
            ctx.beginPath();
            ctx.ellipse(-fish.width * 0.1, swimOffset + finOffset * 0.5, finSize * 0.5, finSize * 0.3, Math.PI / 3, 0, 2 * Math.PI);
            ctx.fill();
            
            // å³èƒ¸é³
            ctx.beginPath();
            ctx.ellipse(fish.width * 0.1, swimOffset - finOffset * 0.5, finSize * 0.5, finSize * 0.3, -Math.PI / 3, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶é±¼çœ¼
        function drawFishEyes(fish) {
            // çœ¼ç™½
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(fish.width / 4, -fish.height / 6, fish.width * 0.08, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ç 
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(fish.width / 4 + 1, -fish.height / 6, fish.width * 0.04, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ç›é«˜å…‰
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(fish.width / 4 + 2, -fish.height / 6 - 1, fish.width * 0.02, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ç»˜åˆ¶é±¼ç±»å›¾æ¡ˆ
        function drawFishPattern(fish) {
            ctx.save();
            
            switch (fish.pattern) {
                case 'stripes':
                    // æ¡çº¹å›¾æ¡ˆ - æ”¹ä¸ºå‚ç›´æ¡çº¹
                    ctx.fillStyle = fish.secondaryColor;
                    for (let i = 0; i < 3; i++) {
                        const x = -fish.width / 3 + i * fish.width / 4;
                        const stripeWidth = fish.width * 0.08;
                        ctx.fillRect(x - stripeWidth / 2, -fish.height / 2, stripeWidth, fish.height);
                    }
                    break;
                case 'scales':
                    // é±¼é³å›¾æ¡ˆ - ç§»é™¤ç™½è‰²çº¿æ¡ï¼Œæ”¹ä¸ºå¡«å……å°åœ†ç‚¹
                    ctx.fillStyle = fish.secondaryColor;
                    ctx.globalAlpha = 0.3;
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            if (i === 0 && j === 0) continue; // è·³è¿‡ä¸­å¿ƒç‚¹
                            ctx.beginPath();
                            ctx.arc(i * fish.width * 0.15, j * fish.height * 0.15, fish.width * 0.03, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    ctx.globalAlpha = 1;
                    break;
                case 'bands':
                    // å°ä¸‘é±¼å›¾æ¡ˆ - ç§»é™¤ç™½è‰²æ¡å¸¦
                    // ä¸ç»˜åˆ¶ä»»ä½•å›¾æ¡ˆï¼Œä¿æŒçº¯è‰²
                    break;
                case 'sparkle':
                    // é—ªçƒæ•ˆæœï¼ˆç¨€æœ‰é±¼ï¼‰
                    ctx.fillStyle = '#FFFFFF';
                    for (let i = 0; i < 5; i++) {
                        const x = (Math.random() - 0.5) * fish.width * 0.8;
                        const y = (Math.random() - 0.5) * fish.height * 0.8;
                        const size = Math.random() * 2 + 1;
                        const alpha = Math.sin(fish.animationTime * 5 + i) * 0.5 + 0.5;
                        
                        ctx.save();
                        ctx.globalAlpha = alpha;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    break;
            }
            
            ctx.restore();
        }
        
        // æ£€æŸ¥é’“é±¼ç¢°æ’
         function checkFishingCollisions() {
             if (!cat || !cat.isFishingActive()) return;
             
             const hookRect = cat.getHookCollisionRect();
             
             // æ£€æŸ¥æ˜¯å¦å·²ç»æŠ“åˆ°é±¼
             if (cat.fishingRod && cat.fishingRod.caughtFish) return;
             
             // æ£€æµ‹ä¸é±¼ç±»çš„ç¢°æ’
             for (let i = 0; i < fishes.length; i++) {
                 const fish = fishes[i];
                 if (!fish.isActive) continue;
                 
                 if (checkCollision(hookRect, fish)) {
                     // æ•è·é±¼ç±»
                     fish.isActive = false;
                     fish.isCaught = true;
                     
                     // è°ƒç”¨Catçš„setCaughtFishæ–¹æ³•
                     if (cat.setCaughtFish) {
                         cat.setCaughtFish(fish);
                     } else {
                         cat.fishingRod.caughtFish = fish;
                     }
                     
                     // å¦‚æœæ­£åœ¨ä¸‹é™ï¼Œç«‹å³å¼€å§‹æ”¶æ†
                     if (cat.fishingRod.isDropping) {
                         cat.startReeling();
                     }
                     
                     caughtFishCount++; // å¢åŠ é’“é±¼è®¡æ•°
                     
                     // æ’­æ”¾é’“é±¼æˆåŠŸéŸ³æ•ˆ
                     playCatchSound();
                     
                     // ä»æ•°ç»„ä¸­ç§»é™¤è¢«æ•è·çš„é±¼
                     fishes.splice(i, 1);
                     
                     // ç«‹å³ç”Ÿæˆä¸€æ¡æ–°é±¼ä»¥ä¿æŒé±¼å¡˜æ•°é‡æ’å®š
                     spawnFish();
                     
                     debugLog(`æ•è·äº†ä¸€æ¡${fish.type}é±¼ï¼æ€»è®¡: ${caughtFishCount}æ¡ï¼Œæ± å¡˜é±¼æ•°: ${fishes.length}`, 'success');
                     break;
                 }
             }
         }
         
         // ç®€å•çš„çŸ©å½¢ç¢°æ’æ£€æµ‹
         function checkCollision(rect1, rect2) {
             return rect1.x < rect2.x + rect2.width &&
                    rect1.x + rect1.width > rect2.x &&
                    rect1.y < rect2.y + rect2.height &&
                    rect1.y + rect1.height > rect2.y;
         }
         
         // æ›´æ–°æ¸¸æˆæ—¶é—´
         function updateGameTimer(deltaTime) {
             if (!isGameActive) return;
             
             gameTimer += deltaTime;
             const remainingTime = Math.max(0, gameTime - gameTimer);
             
             // æ—¶é—´åˆ°äº†ï¼Œç»“æŸæ¸¸æˆ
             if (remainingTime <= 0) {
                 isGameActive = false;
                 debugLog('æ¸¸æˆæ—¶é—´ç»“æŸï¼', 'warning');
             }
         }
         
         // è·å–æ ¼å¼åŒ–çš„å‰©ä½™æ—¶é—´
         function getFormattedTime() {
             const remainingTime = Math.max(0, gameTime - gameTimer);
             const minutes = Math.floor(remainingTime / 60);
             const seconds = Math.floor(remainingTime % 60);
             return `${minutes}:${seconds.toString().padStart(2, '0')}`;
         }
         
         // æ¸²æŸ“è°ƒè¯•ä¿¡æ¯
         function renderDebugInfo() {
             // çº¢è‰²æ¡†åŒºåŸŸæ˜¾ç¤ºï¼šé’“é±¼æ•°é‡å’Œå€’è®¡æ—¶
             // å·¦ä¸Šè§’æ˜¾ç¤ºé’“é±¼æ•°é‡
             ctx.fillStyle = isGameActive ? '#000' : '#FF6B6B';
             ctx.font = 'bold 18px Arial';
             ctx.textAlign = 'left';
             ctx.fillText(`é’“é±¼æ•°é‡: ${caughtFishCount}`, 20, 30);
             
             // å³ä¸Šè§’æ˜¾ç¤ºå€’è®¡æ—¶
             ctx.textAlign = 'right';
             ctx.fillText(`æ—¶é—´: ${getFormattedTime()}`, canvas.width - 20, 30);
             

             
             // æ¸¸æˆç»“æŸæç¤ºå·²ç§»é™¤
         }
        
        function testFishing() {
            if (!cat) {
                debugLog('å°çŒ«å¯¹è±¡æœªåˆå§‹åŒ–', 'error');
                return;
            }
            
            if (!isGameActive) {
                debugLog('æ¸¸æˆå·²ç»“æŸï¼Œæ— æ³•é’“é±¼', 'warning');
                return;
            }
            
            debugLog('æµ‹è¯•é’“é±¼åŠŸèƒ½...', 'info');
            debugLog(`å½“å‰æ± å¡˜ä¸­æœ‰ ${fishes.length} æ¡é±¼`, 'info');
            
            try {
                const canFish = cat.canFish();
                debugLog(`å°çŒ«æ˜¯å¦å¯ä»¥é’“é±¼: ${canFish}`, canFish ? 'success' : 'warning');
                
                if (canFish) {
                    const result = cat.startFishing();
                    debugLog(`å¼€å§‹é’“é±¼ç»“æœ: ${result}`, result ? 'success' : 'error');
                    
                    if (result) {
                        playCastSound(); // æ’­æ”¾æŠ•æ·é±¼ç«¿éŸ³æ•ˆ
                        debugLog('é’“é±¼åŠŸèƒ½æ­£å¸¸å·¥ä½œï¼', 'success');
                    }
                } else {
                    debugLog('å°çŒ«å½“å‰æ— æ³•é’“é±¼ï¼ˆå¯èƒ½æ­£åœ¨é’“é±¼ä¸­ï¼‰', 'warning');
                }
                
            } catch (error) {
                debugLog(`é’“é±¼æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                console.error('é’“é±¼æµ‹è¯•é”™è¯¯:', error);
            }
        }
        
        function testReeling() {
            if (!cat) {
                debugLog('å°çŒ«å¯¹è±¡æœªåˆå§‹åŒ–', 'error');
                return;
            }
            
            if (!isGameActive) {
                debugLog('æ¸¸æˆå·²ç»“æŸï¼Œæ— æ³•æ”¶æ†', 'warning');
                return;
            }
            
            debugLog('æµ‹è¯•æ”¶æ†åŠŸèƒ½...', 'info');
            
            try {
                const isFishing = cat.isFishingActive();
                debugLog(`å°çŒ«æ˜¯å¦æ­£åœ¨é’“é±¼: ${isFishing}`, isFishing ? 'success' : 'warning');
                
                if (isFishing) {
                    cat.startReeling();
                    playReelSound(); // æ’­æ”¾æ”¶æ†éŸ³æ•ˆ
                    debugLog('å¼€å§‹æ”¶æ†', 'success');
                } else {
                    debugLog('å°çŒ«å½“å‰æ²¡æœ‰åœ¨é’“é±¼ï¼Œæ— æ³•æ”¶æ†', 'warning');
                }
                
            } catch (error) {
                debugLog(`æ”¶æ†æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                console.error('æ”¶æ†æµ‹è¯•é”™è¯¯:', error);
            }
        }
        
        function startGame() {
            debugLog('å¼€å§‹æ¸¸æˆ...', 'info');
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameTimer = 0;
            isGameActive = true;
            caughtFishCount = 0;
            
            // æ¸…ç©ºå¹¶é‡æ–°ç”Ÿæˆé±¼ç±»
            fishes = [];
            fishSpawnTimer = 0;
            spawnInitialFishes();
            
            // é‡ç½®å°çŒ«çŠ¶æ€
            if (cat) {
                cat.resetFishingRod();
                cat.mood = 'happy';
                cat.currentAnimation = 'idle';
            }
            
            // å¯åŠ¨èƒŒæ™¯éŸ³ä¹
            if (!window.bgmAudio || window.bgmAudio.paused) {
                playBackgroundMusic();
            }
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            const startButton = document.getElementById('startButton');
            if (startButton) {
                startButton.textContent = 'ğŸ”„ é‡æ–°å¼€å§‹';
                startButton.style.background = '#FF9500';
            }
            
            debugLog('æ¸¸æˆå¼€å§‹ï¼ç‚¹å‡»ç”»å¸ƒè¿›è¡Œé’“é±¼', 'success');
        }
        
        function resetGame() {
            debugLog('é‡ç½®æ¸¸æˆ...', 'info');
            
            // é‡ç½®æ¸¸æˆæ—¶é—´
            gameTimer = 0;
            isGameActive = true;
            
            // é‡ç½®é’“é±¼è®¡æ•°
            caughtFishCount = 0;
            
            // æ¸…ç©ºé±¼ç±»
            fishes = [];
            fishSpawnTimer = 0;
            
            // é‡ç½®å°çŒ«çŠ¶æ€
            if (cat) {
                cat.resetFishingRod();
                cat.mood = 'happy';
                cat.currentAnimation = 'idle';
            }
            
            // ç¡®ä¿èƒŒæ™¯éŸ³ä¹æ­£åœ¨æ’­æ”¾
            if (!window.bgmAudio || window.bgmAudio.paused) {
                playBackgroundMusic();
            }
            
            // é‡æ–°ç”Ÿæˆåˆå§‹é±¼ç±»
            spawnInitialFishes();
            
            debugLog('æ¸¸æˆé‡ç½®å®Œæˆï¼', 'success');
        }
        
        function checkCatState() {
            if (!cat) {
                debugLog('å°çŒ«å¯¹è±¡æœªåˆå§‹åŒ–', 'error');
                return;
            }
            
            debugLog('æ£€æŸ¥å°çŒ«çŠ¶æ€...', 'info');
            
            try {
                debugLog(`å°çŒ«ä½ç½®: (${cat.x}, ${cat.y})`, 'info');
                debugLog(`é±¼ç«¿å¯¹è±¡å­˜åœ¨: ${!!cat.fishingRod}`, cat.fishingRod ? 'success' : 'error');
                
                if (cat.fishingRod) {
                    debugLog(`é±¼ç«¿çŠ¶æ€: ${cat.getFishingRodState()}`, 'info');
                    debugLog(`æ­£åœ¨ä¸‹é™: ${cat.fishingRod.isDropping}`, 'info');
                    debugLog(`æ­£åœ¨æ”¶æ†: ${cat.fishingRod.isReeling}`, 'info');
                }
                
                debugLog(`åŠ¨ç”»ç®¡ç†å™¨å­˜åœ¨: ${!!cat.animationManager}`, cat.animationManager ? 'success' : 'error');
                debugLog(`å½“å‰å¿ƒæƒ…: ${cat.mood}`, 'info');
                debugLog(`å½“å‰åŠ¨ç”»: ${cat.currentAnimation}`, 'info');
                
            } catch (error) {
                debugLog(`çŠ¶æ€æ£€æŸ¥å¤±è´¥: ${error.message}`, 'error');
                console.error('çŠ¶æ€æ£€æŸ¥é”™è¯¯:', error);
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            debugLog('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ', 'info');
            setTimeout(initTest, 100);
            
            // æ·»åŠ ç”¨æˆ·äº¤äº’ç›‘å¬å™¨æ¥å¯åŠ¨éŸ³é¢‘
            document.addEventListener('click', function enableAudio() {
                if (!window.audioEnabled) {
                    window.audioEnabled = true;
                    playBackgroundMusic();
                    debugLog('ç”¨æˆ·äº¤äº’æ£€æµ‹åˆ°ï¼Œå°è¯•å¯åŠ¨èƒŒæ™¯éŸ³ä¹', 'info');
                    // ç§»é™¤ç›‘å¬å™¨ï¼Œåªéœ€è¦è§¦å‘ä¸€æ¬¡
                    document.removeEventListener('click', enableAudio);
                }
            }, { once: true });
        });
        
        // ç‚¹å‡»ç”»å¸ƒæµ‹è¯•é’“é±¼
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            if (canvas) {
                canvas.addEventListener('click', (event) => {
                    debugLog('ç”»å¸ƒè¢«ç‚¹å‡»ï¼Œæµ‹è¯•é’“é±¼äº¤äº’', 'info');
                    
                    // é¦–æ¬¡ç‚¹å‡»æ—¶å¯åŠ¨èƒŒæ™¯éŸ³ä¹
                    if (window.musicReady && (!window.bgmAudio || window.bgmAudio.paused)) {
                        playBackgroundMusic();
                    }
                    
                    if (!isGameActive) {
                        debugLog('æ¸¸æˆå·²ç»“æŸï¼Œç‚¹å‡»æ— æ•ˆ', 'warning');
                        return;
                    }
                    
                    if (cat) {
                        if (cat.canFish()) {
                            testFishing();
                        } else if (cat.isFishingActive()) {
                            testReeling();
                        }
                    }
                });
            }
        });
    </script>
</body>
</html>